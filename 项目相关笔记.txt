
// 竟技场打完一场战斗后继续请求，显示自已在战斗中
// 商店可能需要一个实时更新自已的model

// ajax请求数据失败时的错误处理
	+ 进入路由时请求接口：如果失败ok不为1将路由的cb(parsedata)传入进去，此时不会进入该路由
	+ 如果err同样执行cb(err),此时不会进入该路由

// 竟技场完成战斗调用complete接口时报服务器错误，有可能是hid错误
// {Mixed}指代context(上下文作用域)




数据

角色金币，钻石等货币接口(需要同步数据和展示数目)

- 竟技场
	购买挑战次数的面板没有ui
	规则说明没有文档
	竟技场日志中没有判断是别人打我还是我打别人的字段
	对手人物头像没有
	商店没有货品信息
	角色当前的荣誉值没有
	货品几点更新信息
	竟技场排行榜结算奖励与结算说明没有
	换一批接口没有对方的当前排名字段

- 商城
	没有下一批商品的刷新时间
	刷新下一批商品时没有弹出面板的ui
	商品每天的更新时间没有

- 签到
	物品领取完后没有model可提供同步前端数据

// 今天要完成的任务

// 每一个副本对应的副本名字


// 2016/3/23
人物战斗结束后死了的角色在进入死亡状态后又莫名其妙会进入行走状态

解决过程：
	
	1. 将角色单独拿出来与另一个角色战斗(1 vs 1)
	2. 让其中一个角色将另一个角色杀死，断点被杀死的角色
	3. 其中被杀死的角色已经被移除了大部份的东西
	4. 最终将问题定位到未被移除的action身上

		问题如下：

			由于人物在死亡后把(speed缩小速度放到非常小时)，在死亡状态还有一段非常小的位移(将问题定位到角色从死亡状态又回到跑动状态)
			死亡状态切换成跑动状态的可能性，死亡角色的action未清理干净，此时虽然已经为死亡状态，但是跑动状态的runAction还继续在执行，此时人物还会继续不断递归跑动逻辑，但此时角色会被清理掉大部份的属性，所以会出现各种报错
		解决如下：

			每次从跑动状态切换出去的话，在exit方法内把角色当前的action清理干净后就不会出现刚刚的问题了


// 当前的战斗还有哪些问题
	
	1. 挂机副本：每打完一波怪以后回调complete接口不稳定(偶尔会报undefine err)，之后恢复正常
	2. 主城副本：
		打完副本后处理还未做，此时有多种可能(回到挂机战斗，回到主城副本，回到主城)，每种情况处理逻辑不同
		当打完一个副本后(次数用完)，下次请求接口时，次数打完的副本没有了
	3. 竟技场：
		竟技场战斗完成后未做后续处理
	4. 战斗中人物资源被新资源替换后出现锚点偏差比较大，主要体现在挂在人物身上的血条与人物从有坐骑时切换成没有坐骑时位移偏差较大
	5. 战斗中人物的移动速度还在使用前端测试数据
	6. 战斗中人物的攻击范围还在使用前端测试数据

// 远程攻击技能需要检查内存泄漏

// 2016/3/28
1. 挂机副本改为角色寻怪模式，怪物不会移动
2. 战斗中text（伤害数值）没有被释放完全

// 在处理角色死亡时可能还有未知的问题
1. 角色将怪杀死后被杀死的怪没有进入死亡状态
2. 角色此时与怪还继续战斗
3. 将判断怪是否死去的条件改变了一下，后边可能还会出新的的问题

// 2016/3/31
1. 把小怪的speed属性置为1时runAction时出现故障(这个问题可能会引发其它问题，需要长期观察)

// 2016/4/8
1. 现在的战斗系统总共有：挂机战斗，竟技场战斗，副本战斗，遭遇战战斗
	其中副本战斗与竟技场战斗类似(基本属于pvp摸式)
	挂机战斗中分为挑战挂机boss与可能存在的遭遇战

	挑战挂机boss与竟技场，副本类似(都是以角色为中心，不会有其它干扰)----不会出现stop状态机与run状态机判断不匹配问题
	(stop状态机与run状态机匹配问题：

		1. 在stop状态下，判断有敌人，则直接进入run状态，由run状态机处理追敌与进入杀敌状态
		2. 在stop状态下，判断没有敌人，则认为敌人都被角色杀了，此时分配新敌人
	)
	遭遇战：遭遇战是推送另一个玩家过来与自已形成一个竟争关系，此时会引发一个问题就是stop状态与run状态不匹配问题
	(stop状态机与run状态机不匹配问题：

		1. 在stop状态下，自已玩家判断有敌人，则寻找敌人，可是此时另一个玩家先找到了这个敌人并杀死了它，这时自已玩家还在走的路上
		2. 在stop状态下，判断没有敌人了，此时没什么影响
		3. 在skill状态下，俩个玩家同时选择了同一个敌人(此时肯定需要做处理)，因为此时一定会涉及其中一个玩家杀死了敌人，但另一个玩家正准血砍下去
	)


///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////

战斗问题：
	1. 在将角色的实例直接挂到状态机与技能脚本内改为使用角色管理器用id取技能的形式重构代码：
		在打怪的过程中没有发生异常，直到将怪打死后，在死去的怪物death状态机上处理角色管理器时出现问题，
		如果此时将死去的怪物在状态机内从角色管理器中移除后，这时立刻执行的是把怪物的hp(血条移除)，在过1秒后将怪物的view移除
		这时如果其它地方还需要用角色管理器取这个怪物时就会报错，因为此刻过早马怪物从角色管理器移除了
		比如：技能脚本还要从角色管理器中拿取该角色释放一些垃圾

	2. 在写遭遇战时，当俩个角色同时选取了同一个怪：
		当一个角色先把怪打死了，这时怪死了被清除了大部份数据，而此时另一个角色还可能使用role.enemy属性，但此时enemy的数据是不全的，所以要拦截住
		1. 在run状态机中判断，如果enemy被清理过，则说明怪死了，那么就不要走状态机后面的逻辑，走了会报错
		2. 在扣血时，因为enemy都已经死了，死了不作扣血，否则报错
		3. 还有一个代码执行顺序的问题(很多时候都是代码执行顺序出的问题)，怪死了进入状态机作数据清理，此时如果角色A把怪打死了，角色B还在跑动，则直接在run状态机处可以拦截住
			如果B不跑动了，跟A是差不多同时攻击的怪，但A出手快先抢走人头，此时应该是在技能脚本中拦截死亡状态

		4. 还有一个可能会出现的问题：当俩角色同时出手，角色A执行了攻击把怪打死，角色B也执行了攻击，但没执行完complete事件，怪又死了，此处有可能会出现一些异常
		//////////////////////////////////////////////////////////////////////////////////////////////////////
			这几个错误还是比较难于发现，以后出现类似情况应先从这几个方向入手查找问题
		/////////////////////////////////////////////////////////////////////////////////////////////////////

// 2016/4/9
1. 在清除一个角色时，主要清除哪些东西：
	角色状态机
	角色技能
	扣血状态

// 2016/4/10
1. ps记录动作：
	菜单栏下拉条中选中动作项(或者快捷键alt+f9)打开动作菜单
	点击新建动作，开始操作，操作的每一步将会记录下来
	操作完成后点击完成记录

	以后直接点击播放动作就可以播放该动作了
2. ps快速裁9宫格
	选中选区，选择要移除的区域后用delete键移除
	在选中要合并的其中一项，右键选择自由变换将图片合成一张图(回车完成)
	保存图片


// 2016/ 4 / 14

# 召唤师学院新手引导修改


//2016 / 4 / 15

# 世界boss

+ 世界boss战斗中以boss为中心，玩家角色围攻boss，此时在将camora切换target时只是将原来camore的target(当前玩家角色visible = false，应当把其当前状态都移除)

+ 现在的战斗有很多模块依赖hp实例
	
	世界boss角色没有hp实例
	扣血飘字时依赖hp

// 2016 / 4 / 16
世界boss模块

当前玩家死了，此时如何记录30秒倒计时时间
怪物与角色用同一套技能脚本，所以出现当怪物与玩家战斗时玩家放技能错乱bug

// 2016 / 4 / 16

世界boss结算处理都使用complete接口，evt方法只做血条同步与实时排位同步



召唤师学院新手引导修改

测试链接： dev_test
1. 删除装备进阶引导
2. 删除技能加点引导
3. 第1关卡战斗完不进入装备引导，改为引导进入第2关战斗
4. 第2关卡战斗完引导穿装备
5. 第4关卡战斗完引导交付任务
6. 第6关卡战斗完引导喝经验药水
7. 第8关卡战斗完引导扫荡
8. 所有修改的引导都是严格按关卡开启触发的，如果以上非强制引导被跳过则默认不引导，以后也不会再引导


js中~操作符按位取反
~~类型转换~~null为数字类型

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1. 个人boss血条
2. 人物传送
3. 升级特效
4. 世界boss
5. 战士技能
6. 地图切换
7. 换状换坐骑
8. 战斗回路
9. 掉落动画

宠物--------------------------
遭遇战------------------------


/////////////////////////
// 
/////////////////////////

1. 未实现的功能：点哪走哪的功能
2. 手机上挂久了掉帧问题
3. 地图有黑边(没有及时加载下来)
4. 代码结构现在没有问题

// 战斗体系

人物：	打普通怪物
		打boss
		做任务


// 跨域
定义：跨域是指从一个域名的网页去请求另一个域名的资源，比如从www.baidu.com的页面请求www.google.com的资源
严格定义：只要协议，域名，端口有一个不同都被当作是跨域

// 小积累
// 检查字符串包含子串
'string'.indexOf()
'string'.includes()

[1,2,3,4,5,6].indexOf(value)
!!~[1,2,3,4,5].indexOf() // 返回一个bool值

arrow函数(ES6)
(参数1，参数2.....) => {条件，语句......} // 匿名函数

setInterval(function() {
	

},100);

setInterval(() => {
	

},200)
setInterval(function() {
	
	// bind方法绑定this后,匿名函数内可以直接访问this指针
}.bind(this),1000);

// 测试一段代码的性能
console.time('执行代码块')

````代码块````

````代码块````

console.timeEnd('执行代码块')

// 模板字符串(ES6)
${}
var str1 = 'love';
var str2 = 'you';
console.log('i ${str1} ${str2}');

// eval()函数
将字符串'onString'化
var str = '{"name":"lalalalalala","age":100000000}';// 字符串嵌套时，外层用'',内层用""
eval(str);// 错误，不用执行
eval('(' + str + ')');// 正确，可以将str转化为一个对象

() 会把语句转换成表达式，称为语句表达式。括号里的代码都会被转换为表达式求值并且返回
一个 JSON 对象或者说是一个对象根本就不是能执行的 JavaScript 语句

////////////////////
// 
////////////////////
//使用哪种方式来使俩个精灵相互战斗时有一个时间停顿
	1.在战斗场景由控制器开关定时器，每次精灵发起攻击时，定时器停止，攻击完成后定时器开启（继续检测下一回合）
	2.由攻击动作本身控制，动作本身有停顿

//如何在主场景灵活控制定时器
1.攻击动作从开始到完成为第一阶段
2.动作完成后

//2015/11/23
主角状态：
	
	形为：普攻、死亡、停止、行走
							行走：上、下、左、右、左上、左下、右上、右下
	1.未找到目标(未进入双方的攻击范围)
		一直保持行走状态
	2.找到目标(已进入双方的攻击范围)
		保持停止并准备进入普通攻击状态
	3.打不过对方
		进入死亡状态

////////////////////////
// 
////////////////////////
# 算法核心

## A*估值算法

### 寻路估值算法有非常多：常用的有广度优先算法，深度优先算法，哈夫曼树等等，游戏中用的比较多的如：A*估值

### 算法描述
+ 对起点与终点进行横纵坐标的运算(非常简单)

### 代码实现
* start: 起点坐标(point)
* end: 终点坐标(point)
* `Math.abs(start.getX() - end.getX()) + Math.abs(start.getY() - end.getY());`

# 算法逻辑
+ *寻路过程中检索关联点(路径点)*
+ *对关联点分类(分为已经关联与未关联)*
+ *对未关联的点用寻路算法对其进行一次标识(每个点需要3种标识)*
+ *对比关联点的标识找出下一步的最优路径*
+ *循环上几步的操作，直到终点*

# 算法实现
* 定义一个容器，在js中使用数组[ ]，为了更好描述算法，在Array中实现几个方法：

判断容器中是否存在该点:
````
// 根据对象判断
Array.prototype.isExistByValue = function(value) {

    for (var i = 0; i < this.length; i++) {

        if (value.getX() == this[i].getX() && value.getY() == this[i].getY()) {

            return this[i];// 对象总是为真
        }
    }

    return false;
}
// 根据对象中的属性值判断
Array.prototype.isExistByProperty = function(x, y) {

    for (var i = 0; i < this.length; i++) {

        if (x == this[i].getX() && y == this[i].getY()) {

            return true;
        }
    }

    return false;
}
````
移除一个点:
````
// 根据点的属性值移除点
Array.prototype.removeValue = function(x, y) {

    for (var i = 0; i < this.length; i++) {

        if (x == this[i].getX() && y == this[i].getY()) {

            this.splice(i,1);
        }
    }
}

// 根据对象删除点
Array.prototype.remove = function(value) {

    for (var i = 0; i < this.length; i++) {

        if (value == this[i]) {

            this.splice(i,1);
        }
    }
}
````
添加一个点:
````
// 根据点的坐标属性添加点到容器中
Array.prototype.add = function(x, y) {

    var v = new pathUtils.locationPoint(x,y);
    this.push(v);
}
````
根据点对象从容器中拿取该点，没有return null:
````
Array.prototype.getValue = function(value) {

    for (var i = 0; i < this.length; i++) {

        if (value.getX() == this[i].getX() && value.getY() == this[i].getY()) {

            return this[i];
        }
    }

    return null;
}
````
根据点的某一属性取出该点:
````
// 把最小F值的point找出来
Array.prototype.getValueByProperty = function() {

    var minF = this[0].getF();
    for (var i = 0; i < this.length; i++) {

        if (minF > this[i].getF()) {

            minF = this[i].getF();
        }
    }
    for (var i = 0; i < this.length; i++) {

        if (minF == this[i].getF()) {

            return this[i];
        }
    }

    return this[0];
}
````
* 寻路逻辑:
````
pathUtils.pathLogic = function(start, end, obstacArr) {
    
    this.openList = [];
    this.closeList = [];
    this.openList.push(start);
    while(this.openList.length != 0){
        
        var smallF = this.openList.getValueByProperty();
        this.openList.remove(smallF);
        this.closeList.push(smallF);
        var suround = this.getSurroundPath(smallF,obstacArr);

        for (var i = 0; i < suround.length; i++) {
            
            var tempObj = this.openList.isExistByValue(suround[i]);
            if (tempObj) {

                this.foundInOpenList(smallF,tempObj);
            }else{

                this.notFoundInOpenList(smallF,end,suround[i]);
            }
        }
        if (this.openList.getValue(end) != null) {

            this.closeList.push(end);

            return this.closeList;

        }
    }
}

pathUtils.calcG = function(start, point) {

    var G = (Math.abs(point.getX() - start.getX()) + Math.abs(point.getY() - start.getY())) == 1 ? utils.Const.PATH_HORIZONTAL_VERTICAL : utils.Const.PATH_OBLIQUITY;
   
    return (G + point.getParentPoint().getG());
}
pathUtils.calcH = function(end, point) {

    var h = Math.abs(point.getX() - end.getX()) + Math.abs(point.getY() - end.getY());
    return h * utils.Const.PATH_HORIZONTAL_VERTICAL;
}

pathUtils.getSurroundPath = function(point, obstacArr) {

    var surroundArr = [];

    for (var i = point.getX() - 1; i <= point.getX() + 1; i++) {

        for (var j = point.getY() -1; j <= point.getY() + 1; j++) {

            if (this.closeList.isExistByProperty(i,j)) continue;
            if (obstacArr && obstacArr.length && obstacArr.isExistByProperty(i,j)) continue;
            
            surroundArr.add(i,j);
        }
    }

    return surroundArr;
}

pathUtils.foundInOpenList = function(tempPoint, point) {

    var G = this.calcG(tempPoint,point);
    if (G < point.getG()) {

        point.setParentPoint(tempPoint);
        point.setG(G);
        point.calcF();
    }
}

pathUtils.notFoundInOpenList = function(tempPoint, end, point) {

    point.setParentPoint(tempPoint);
    point.setG(this.calcG(tempPoint,point));
    point.setH(this.calcH(end,point));
    point.calcF();
    this.openList.push(point);
}
````

# 算法细节

## 需要注意的几点
+ *点对象中标识G的计算*
+ *点对象中标识H的计算*
+ *点对象已经被关联过*
+ *点对象未被关联过*

## 要点突破
* *当前起点与终点的parent是为null(没有父节点的概念)*
* *G值计算:*

 1. 相对于起点G值一直增大(横竖走一步消耗为10,斜向走一步消耗为14)

 2. G值有8个方向需要计算

 3. G值总是越靠近终点值越小

* *H值计算:*

 1. 相对于起点H值一直减小(离终点近一步-10,离终点远一步+10)

 2. H值有4个方向需要计算

 3. H值相对于终点是不变的

* *点已被关联过:*

 1. 如果某个相邻方格已经在openList里了, 检查如果用新的路径 (就是经过最优点的路径) 到达它的话, G值是否会更低一些,
 2. 如果新的G值更低, 那就把它的parent改为目前选中的方格, 然后重新计算它的 F 值和 G 值 (H 值不需要重新计算, 因为对于每个方块, H 值是不变的). 
 3. 如果新的 G 值比较高, 就说明经过最优点再到达该相邻点不是一个明智的选择, 因为它需要更远的路, 这时我们什么也不做.

* *点未被关联过:*

 1. 检查它所有相邻并且可以到达 (障碍物和closeList的方格都不考虑) 的方格. 如果这些方格还不在openList里的话, 将它们加入openList, 计算这些方格的 G, H 和 F 值各是多少, 并设置它们的parent为该最优点.

# 算法总结
+ 宏观来说，A*算法并非是寻路中最好的算法，但由于其实现简单所以在工程中大量使用
+ A*寻路整体不是非常难，只要注意细节就不会出现bug

////////////////////////
// 
////////////////////////
//2015/10/30
1.新项目为一款挂机游戏
2.基本要求:
	1.可以自动寻路
	2.可以自动战斗

//2015/10/31
3.主场景：平铺地图，能够自由切换地图(有无地图不能影响游戏的进行--用单独的类管理地图),有一个时该检测两点距离的定时器
4.人物(player and enemy):
	base:{
		运动逻辑：{上，下，左，右，斜上左，斜上右，斜下左，斜下右}
		运动动画：{上，下，左，右，斜上左，斜上右，斜下左，斜下右}
		运动状态：{UP,DOWN,LEFT,RIGHT,UPLEFT,UPRIGHT,DOWNLEFT,DOWNRIGHT}
		属性状态：{DIE(是否死亡bool),attackRange(攻击范围numbel),bloodBar(人物血条object,血条可以用单独的一个类，可以被人物代理(实现一些代理方法来管理)),damageValue(当前伤害值numbel),speedValue(当前的速度numbel)}
		自身检测能力：UP --> 上(动作) --> 上(动画)
					  DOWN --> 下(动作) --> 下(动画)
					  LEFT --> 左(动作) --> 左(动画)
					  RIGHT --> 右(动作) --> 右(动画)
					  UPLEFT --> 左上(动作) --> 左上(动画)
					  UPRIGHT --> 右上(动作) --> 右上(动画)
					  DOWNLEFT --> 左下(动作) --> 左下(动画)
					  DOWNRIGHT --> 右下(动作) --> 右下(动画)
	}
	player: public base{
		战士：Soldier
		法师：Rabbi
		猎人：Hunter
	}
	enemy: public base{
		A:
		B:
		C:
	}
+------------------------------------------++--------------------------------------++------------------------------------------+
|	  		战士(Soldier)                  ||           法师(Rabbi)                ||           猎人(Hunter)                   |
|     1.战士是否有特别任务剧情             ||     1.法师是否有特别剧情             ||      1.猎人是否有特别剧情                |
|     2.Soldier的技能特点(SKILL_SOLDIER)   ||     2.Rabbi的技能特点(SKILL_RABBI)   ||      2.Hunter的技能特点(SKILL_HUNTER)    |
|     3.Soldier的属性特点(PROPERTY_SOLDIER)||     3.Rabbi的属性特点(PROPERTY_RABBI)||      3.Hunter的属性特点(PROPERTY_HUNTER) |
|     4.Soldier的速度特点(SPEED_SOLDIER)   ||     4.Rabbi的速度特点(SPEED_BABBI)   ||      4.Hunter的速度特点(SPEED_HUNTER)    |
|     5.Soldier的攻击加成(DAMAGE_SOLDIER)  ||     5.Rabbi的攻击加成(DAMAGE_BABBI)  ||      5.Hunter的攻击加成(DAMAGE_HUNTER)   |
+------------------------------------------++--------------------------------------++------------------------------------------+
1.所有的角色都是继承自基类base
2.所有的角色都在基类base的基础上有自已的拓展
3.继承自base类的所有子类都具有检索功能(检索功能应当与人物一起绑定-----人物自已拥有检索其它角色的能力)



//2015/12/1
当前项目：
1.地图随人物移动过程中会走乱，需修复
2.人物在杀完一波敌人后定时器会乱

//2015/12/2
1.人物一对多战斗
2.使作缓存
[js前端]：
2种方式渲染页面
	1.使用h5中的div与css

	function Layer(doc){
		this._div = doc.createElement('div');
		this._sty = this._div.style;
		//通过定义接口或直接赋值来间接或直接设置div的css属性
		this._sty.position = 'absolute';
		this._sty.overflow = 'hidden';
	}

	Layer.prototype.setX = function (v) {
		this._sty.left = v + 'px';
	}

	Layer.prototype.setY = function (v) {
		this._sty.top = v + 'px';
	}

	Layer.prototype.setWidth = function (v) {
		this._sty.width = v + 'px';
	}

	Layer.prototype.setHight = function (v) {
		this._sty.hight = v + 'px';
	}

	2.使用canvas渲染
	直接获取上下文getContent('2d')


	// 2015/12/3
	1.修复了地图乱走的状态

	// 2015/12/4
	1.一步的距离与速度的关系
	2.多对多战斗时如何保证游戏的进行


	3.  当英雄根据路径辨别方向时：

		如果路径数组只剩2个坐标点，此时还会进行一次方向辨别，当辨别完方向将再次移除路径数组的一个坐标点

		此时路径数组只剩1个坐标点，这时英雄寻路完成，正常情况是进入战斗---

		当战斗完成后进行下一次寻路：

		此时判断是否走完一格的条件如果无法成立则不会在进行下一次的寻路

// 2015/12/7
1. 项目中的层级关系：
	地图层
	中间层
	人物层
	顶层
	1>. 地图层为第0层
	2>. 中间层为第1层，buff效果，技能特效
	3>. 人物层为第2层，分为4个子层：
								精灵层，攻击效果层，血条层，阴影层
								精灵层：sprite所处的层
								攻击效果层：攻击的效果展示
								血条层：血条放置层
								阴影层：人物脚底部份的阴影
	4>. 顶层为第3层，特效处理
2. 技能脚本：将角色技能分脚本写，技能逻辑--
	技能脚本管理器：根据不同角色的id获取角色部分属性，根据属性返回一个合理的技能
3. 人物管理机制：定义一些委托数据与委托类，能正确反应该角色的性格特征
4. 状态机：人物的每一种状态都有一种逻辑与其对应，根据传入的角色id获取当前状态下的角色的逻辑数据，返回这个逻辑
	状态机管理器：能够根据状态来选择使用合理的状态机，在角包切换状态时能处理之前状态的清理工作，也能及时切入下一状态
5. 数据模型：初始化角色当前所有的数据，并能很好处理数据间的传值
6. AI：
	寻路AI：
	寻敌AI：


// 2015/12/10
1. 添加人物技能：
	-将人物普通攻击当成技能释放
	-技能与技能间成为互斥关系
	-人物与人物间的技能不相关

// 2015/12/11
1. 工程项目中尽量少用事件，如果使用了事件应及时清除，尽量使用once事件

2. 技能脚本：
	1. 技能管理器：SkillManage
	2. 技能文件：skill1,skill2,skill3
	SkillManage:
		挂到人物身上，当人物需要技能时候从SkillManage中取出，如果技能管理不挂到人物中，比较难管理技能
		SkillManage中需要提供一个提取技能的方法：getSkill,在getSkill中返回的技能应该是当前最合适的(其中包含了大量了过滤判断，取出最合适的技能)
	skill1,skill2,skill3....每一个具体的技能对象
	// 技能最好能分文件写
	skill1 = {

	}
	skill1.check = function() {

		// 检测当前技能是否满足释放
		// 检测优先级下技能释放的可能性

	}
	skill1.create = function() {

		// 创建该技能
		// ui视图创建
		// 数据创建
		// 返回一个技能对象

	}
	skill1.destry = function() {

		// 如果技能释放完，释放该技能空间
		// 如果技能被别人打断，释放该技能空间
	}


// 2015/ 12/ 14

1. 地图中间层搭建
2. 物品掉落


// 2015 / 12 / 15

1. 寻路前要判断是否在同一位置，如果是，不寻路，已经找到，如果不是，开始寻路
2. 开始寻路时，判断是否只相差一步，如果是，特殊处理，如果不是，正常走
3. 将人物检测相交使用坐标的形式(原来使用距离检测，相对不精确)

4. js中异步操作：setTimeOut可以在不阻塞线程的基础上实现异步操作，但对于时间的把控并不可控
	在js中开子线程对于程序兼容性影响比较大，一般不推荐使用
	尽量使用异步回调的方式解决程序中的一些问题



// 2015 / 12 / 16

1. 寻路算法完善(准确性)
2. 俩个精灵的碰撞检测方式
3. 战斗中的俩个精灵的位置调整
4. 掉落物捡取

5. 在检测位置间关系时，如果不会出现开根号等无限小数，则不需要使用Math.floor或者Math.round方法，这俩个方法一般只用于粗略判断。对于精确定位精灵位置没有实
	际应用价值

// 2015/ 12 / 17

1. 寻路算法是准确的，(只是在定位精灵位置时出现浮点数值，最终根据Math.floor方法进行位置转换时出现误差)
2. 如果不使用Math.floor方法对精灵位置进行误差取整的话，寻路算法pathLogic将会无限不能寻路，与浮点数关系非常大(不兼容浮点数)
3. 需要设计更加准确的方法调整精灵移动与战斗中的位置

// 2015/ 12/ 18 

1. 


// 2015/ 12/ 19

1. 寻路目标寻找，应该是寻找目标周围的站位点
2. 过滤人物重叠，人与人间互为障碣物

// 2015 / 12 / 21 
1. 障碣物有等优化

// 2015/ 12 / 22
1. js中数组pop一个元素后会删除该元素
2. 寻路中如果同一点，会死循环

// 2015/ 12 / 24
1.使用定时器的优点：
	统一管理一个经常调用的方法如：此方法用于递归，一个逻辑的循环。。。。
// 2015 / 12 / 25

1. 代理charles
	1>. 将线上玩吧前端代码代理到自已本地（本地代码）
		map from (线上前端路径) ----- map to (本地前端路径)
	2>. 将线上服务器（后端）代码代理到本地
		map from  （线上服务器路径/*） map to (本地服务器路径/)

2015 / 12 / 26

项目总结：

	1.> 帧动画切换
		在任一时该能否灵活切换所需要的动画，
		是否能够将任一动画置于任一指定位置播放
	2.> 地图是否会越界
		角色移动到地图边界时，地图应该停止移动
		地图要在角色移动到任一位置前先渲染完成
	3.> 角色移动
		角色的站位是否符合预期
		角色的寻路路线是否符合预期
		当俩个阵容的角色一起移动，寻路的路线是否符合预期
		过滤不需要寻路时的寻路(死循环)
		当寻找到对方时的站位是否符合预期
		俩个角色的攻击距离是否符合预期
		

2015 / 12 / 28 

项目战斗系统：
	1. 角色监听事件，当角色进入怪物区，重新对所有人物定位
	2. 角色选择一个最优点到达(目标点)
	3. 怪物到达目标点周围的站位点

// 2015 / 12 / 31

1. skill manage 
2. skill
3. 
4. 进入技能状态
5. 获取技能管理器
6. 技能管理器选择一个合适的技能
7. 开始释放技能
8. 角色的动画
9. 技能的动画
10. 角色动画完成后回调：判断此时下一个最合适的技能？
11. 技能动画完成后回调：判断此时所有敌人是否死亡？
	如果所有敌人都死了，进入捡取掉落状态
	如果还有敌人没有死，选择下一个合适的敌人，继续进入skill状态，直到所有敌人死亡

// 2016 / 1 / 5

1. 每一个角色在任一时刻都只有一种最优先技能，首先要做的是取出该技能

// 2016/ 1 / 13

1. 调通技能与人物的联系

// 2016/ 1 / 14

1. 调试各个技能协调性
2. 寻路摇摆问题
3. 俩个人物重叠问题
4. 当一个技能已经开始后怎样做到实时检测并拿到下一个技能

技能模块中
    1. 使有action时如何预判时间，近距离与远距离在时间一样的情况下速度不同

// 2016 / 1 / 18

1. 首先解决处理技能中内存无法释放的问题
2. 人物站位问题可以往后放
3. 其它问题可以先解决

// 2016 / 1 / 19
gulp 配置0.12.1版本node.js
// 2016 / 1 / 20
gulp中常用的node.js的stream API

gulp.task()
gulp.src()//读入流
gulp.dest()//写入流
gulp.watch()

// 2016 / 1 / 21

战斗中英雄与英雄的朝向需要根据夹角判断最终朝哪个方向
英雄与英雄的朝向确定后再确定技能的方向

// 2016 / 1 / 26
1. 通过变量名直接引用变量，系统直接完成变量名与其存储地址间的转换，称为变量的直接引用 char a;a = 10;
2. 在指针没有指向确定地址时不要对其进行赋值操作 char *p;*p = 10;//这是错误的
3. 用例1：swap(a,b)方法，如果没有指针ab的值交换不过来，即在这个函数内部根本无法改变外部的实参
4. 指针分类，一种类型的指针指向同一种类型的变量

////////////////////////////
//
////////////////////////////
function foo() {
	
	getName = function() {alert(1)};// 此时有var定义getName与没有var定义getName是非常不同的,有var时getName属于foo函数的属性，没有var是foo上一层或window对象的属性(视具体情况而定)
	return this;
}
foo.getName = function() {alert(2)}; // 为foo方法创建了一个getName的静态属性存储了一个匿名函数
foo.prototype.getName = function() {alert(3)}; // 为foo的的原型对象创建了一个getName的匿名函数
var getName = function() {alert(4)}; // 通过函数变量表达式创建了一个getName函数
function getName() {alert(5)}; // 通过函数声明创建了一个getName函数

1. foo.getName() // 调用foo的静态属性弹出2
2. getName() // 所有的声明变量与声明函数都会被提升到当前函数的顶部弹出4
       			拆分成：var getName; 
       		   	function getName() {alert(5)};
       		   	getName = function() {alert(4)}; // 把5覆盖了
3. foo().getName() // 首先调用foo()函数，调用foo()函数的返回值对象的getName方法
				foo函数内的getName方法是没有var的，返回值对象先在foo函数内找是否有getName方法，如果没有从foo函数的上一层找，找到了var getName = function() {alert(4)};
				这果用getName = function() {alert(1)};这条语句覆盖了

				// 
				// this指什么，看foo函数是被谁调用的，谁调用指向谁
				// foo()此时是直接调用(window对象调用)，此时this指向window对象
				// 

				结果弹出1
4. getName() // window.getName(),本来是弹出4的，但在执行3时修改了window对getName()方法调用的结果此时弹出1


// 项目
1. 根据人物速度属性与距离求时间
2. 扣血的时机与人物动作匹配(近战)，远战与技能匹配
3. role构造类要有一个destroy方法，这个方法能够将role这个类里边所有属性清空(数组，对象......)
4. action清理时用removeAllActionFromTarget方法
5. texture清理时用pixi自带的destroy方法
6. 人物在寻路时需要区分障碣物(障碣物处理是用一个数组还是用一个属性管理)
7. 点击寻路
8. 随从与角色需要寻同一个怪


///////////////////////////
// 
///////////////////////////
1. 远程攻击时角色朝向不吻合

	分成8个区域，在各区域内取夹角最小的方向
2. 技能发出时与角色动作不吻合

	法师8个方向手的位置(技能发出的位置)
	猎人8个方向弓弩的位置(箭射出的位置)
	角色初攻击的位置(身体中心点为受击点)
3. 明天的计划
	1. 解决远程攻击的英雄在跑动的过程中会出现屏幕震动的过程
	2. 各类角色在受到远程攻击的时候武器消失的时机与爆点特效的位置(每个英雄都要有一个配置文件)
	3. 在获取跑动方向的时候，在获取方向的方法中要有错误处理机制(这个问题已经查明原因，是因为随机分配敌人时将敌人与角色配到同一点了)

///////////////////////////
// 
///////////////////////////
1. 猎人与法师在寻路时出现地图抖动的现象
2. 猎人与战士移动地图不会抖动
3. 法师与战士移动地图不会抖动
4. 分配敌人时不能将敌人分配与角色同一位置，否则路径为空且获取人物朝向时报错

5. 现在多v多模式以英雄与英雄对战为准，每个角色都独立寻找其它角色，(随从后面可能会变，角色与随从都攻击同一个敌人)
	当前是以友方单位为障碍物，随从攻击距离大于角色攻击距离（人物可以不断错开，防止跑动时重叠在一起）
6. 现在项目中比较棘手的问题有：人物在走时（远程攻击角色）地图出现抖动，暂时没有查出是哪出的问题
7. 角色放技能时与武器的配置文件需要写一下
8. 角色在跑动时要时实处理一些位置问题
9. 敌人分配的位置需要设计一个算法（很可能后面服务器不会给位置信息）

/////////////////////////////
// 
/////////////////////////////
1. 法师与猎人跑动时地图抖动
2. 使用对象缓存后会出现帧事件不触发
3. 战士技能特效缩小一点
4. 有几个技能还有一些问题