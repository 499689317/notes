
## 2017/1/7

	从2016年年初到现在一直在做关于游戏前端，从原来只有pixi.js渲染库到现在相对完善的开发环境集合，总得来说进步有以下几点：
1. 数据同步使用指令形式，无须模块开发人员关心数据同步
2. ui使用xml标签模式堆叠，很大程度减小bug出现
3. 开发模块中使用大量的刲装组件，使开发更专注于逻辑
4. 前端建立字库方便后期跨语言移植
5. 
	指令同步数据解决了第一个项目中前端数据经常不同步的弊端，前端建立了各个模块的数据模型，使前端数据更加健壮，不易出错，
数据问题彻底与ui视图分离，使数据查错与获取更加方便
	ui使用标签来写主要是一种编程思想的统一，为的是当同步的数据改变时能更方便的刷新ui，主要还是解决了数据与ui的表现统一
问题，同时很大程度降低了前端开发的难度。在第一个项目中主要遇到的问题是ui刷新的问题，很多时候数据已经变了，但是视图没变
或者变成其它样式。
	组件刲装也是很大的进步之一，原有的pixi.js在对一些控件的刲装上是很薄弱的。很多时候须要前端开发人员自己实现各种控件，这
么做导致的问题很多。很多重复控件功能相同难统一导致维护成本高，并具相同的代码多且杂。使用统一控件是比较省心的做法，控件的高
度统一解决了开发后期新功能添加与维护的成本，代码简洁高效。
	建立字库也可以说是进步，后期将比较快生成其它语言版本


	主要用第一个项目代码与第二第三个项目代码进行对比，第一个项目主要做了签到，充值，部分活动，新手引导等模块，其中主要遇到的
问题有数据同步出错，数据同步ui出错，控件实现过多，代码重复杂且乱。
	从第二个项目开始，为了解决这些问题，分别经厉了几个阶段：
1. 抽取视图
2. 抽取数据
3. 更新数据
4. 刷新视图
	抽取视图相对比较简单的过程，根据psd原图进行摆放即可，这个过程需要根据文档判断一些特殊的ui，这些ui需要能够根据数据时实更新，
一般可以将这些ui置为全局变量，在一个更新方法内取出这些ui进行时实更新。比较好的方法可以用一个全局容器来装这些ui，相比于前者更
符合前端MVC的思想。
	抽取数据主要是从数据模型中拿取数据(也可以从数据库中拿)，这个过程需要注意的是js对象的引用特性，所以一般在抽取数据时都是拿取
数据的副本进行操作，这个过程比较重要。对象深拷贝即可
	更新数据更多的是对数据的操作，实现一些简单的排序算法与查找算法必须要会。控件操作总是伴随数据的变化，这一步主要要注意的是
对数据操作正确性，操作前的数据需要确保是正确的副本，打样作后的数据要确保是正确的，确定数据没有问题后才能将数据同步至数据库中
前端相对不要求性能高的算法，所以前端相对比较好处理数据
	对数据的更新意味着视图的变化，如何将视图变为我们想要的视图是最终结果。这一步有几种方法可以借鉴：
1. 所有ui刷新一遍
2. 指定ui刷新一遍
	所有ui刷新一遍是比较好的方法，但是性能没有第二种方法好。这种方法优化方案是遍历所有的ui，将数据改变的ui刷新，未变的ui跳过，
这个过程需要将所有ui存入容器中，每次更新都遍历。这么做的好处是不会有需要更新的ui因为疏忽而露掉更新，很大程度上减少问题出现，开
发中这种方法也比较常用
	第二种方法是将指定要更改的ui抽取出来更新，这种方法性能比较好。但带来的问题也很多，当需要更新的ui比较多时，有些ui很难抽取出
来，并且很可能会漏掉部分ui忘记更新。后期维护也会因为一些原因将问题复杂化。

1. 游戏主玩法，如战斗
2. 资源处理
3. ui模块
	游戏项目一般来说有一个主循环，这个主循环是整个项目的驱动，一般来说可以自定义这个循环的频率，但是主流的是一秒跑60帧。按照人
眼的视觉体验60帧是非常顺畅的，但是实际上项目跑不满60帧，不过人眼在24帧以上是不会感觉卡顿的。所以即使跑不满帧也不影响游戏的体验
游戏场景中有比较多的模块都需要主循环的定时器，一方面是为了节省性能(另外增加定时器会影响游戏性能)，另一方面是使游戏体验更佳(一秒
钟画60帧)，这点在战斗场景中非常重要，为了让人物在地图中移动流畅就须要高帧率。如果帧率低于24帧，则会感觉卡顿。
	
战斗模块

1. 地图推图
2. 人物移动
3. 战斗特效
	地图推图中要注意的是地图加载方式，如果使用大地图，则一次性加载一张地图，如果使用拼接的方式加载地图，则需要处理地图资源并按
规则将加载下来的地图碎片重新拼接，未加载的图片将用默认地图替换。
	人物移动主要是寻路算法与边界处理，寻路算法主流的有A*寻路，图寻路。。。。人物在移动过程中不能超出地图边界
	战斗特效主要在战斗pk中出现，与技能脚本关系紧密

	资源处理注意点：
1. 资源命名规则
2. 资源合并
3. 资源压缩
	这部份主要使用一些脚本工具来完成，需要注意的还是命名规则，代码中一般是根据资源名称来拿取资源。

	ui模块主要是游戏的各个玩法模块，新项目中主要写了以下几个模块：
1. 竟技场
2. 战斗场景中的各种ui
3. 聊天模块
4. 帧动画展示的控件
5. 历练模块
6. 邮箱
7. 地图ui
8. 坐骑成长线模块
9. 跑马灯
10. 充值
11. 商城
12. 熔炼
13. 翅膀模块
14. 武林争霸

新项目写了邮箱，聊天，跑马灯的服务器。
聊天服务器主要以广播消息为主，一个区为一个世界聊天，数据库存取5条聊天记录和5条系统消息
跑马灯使用聊天服务器频道推送消息
邮箱需要注意的是领取附件的邮件，需要做同步数据操作

4-1. js与其它语言的差异性还是非常明显的
4-2. 在js中构造函数相对比较随意，一般一个构造函数可以匹配所有实例，但一般在C++中一个类利用函数重载可以有多个构造函数，
		 构造函数与实例严格匹配或者最佳匹配：
		 Thing()
		 Thing(int a)
		 Thing(int a, int b)
		 Thing(int a= 0, int b = 0)
		 这些构造函数间在任意组合的过程很容易产生二义性
4-3. js依靠弱类型可以很轻松避免父子关系带来的二义性，但在C++中这个严格区分的，因为C++中为了能实现对未来代码的拓展加入了一个叫动态绑定的机制，
		 即程序在编译时并不知道要调用哪一个方法，只有在运行时才能确定真正调用的是谁。这也是C++中非常重要的一个特性多态的原理：用一个父类的指针指
		 向一个子类的对象时，这个指针可以调用父类及子类所有方法。并且这些方法一般会声明为虚函数，此时指针在指向这些方法时，编译不能确定是父类还
		 是子类，只有在运行时才知道
4-4. js在传参这一块依然与其它语言有一定差异，在C++中传参有三种方式，第一种比较常见的传指针，第二种传值，第三种传引用。一般来说传指针与传值
		 传参是单向传递的，形参与实参是互不影响的，第三种传引用与js中的传引用也有一定区别，C++中引用使用&符号，它只代表另一个变量的一个别名，没有
		 其它任何意义，当变量改变时，所有引用都是改变的，所以传引用是双向传递。并且在拷贝构造函数中是一定要传引用的，否则后果不堪设想。
4-5. js功能强大与直接使用操作符一样，但是在其它语言这是非法的，在C++中你可以对一些基本类型使用 == 操作符或 = 赋值操作符等等，但是这涉及到c++的
		 一个知识点深拷贝，当对一个指针进行这些操作时 = 号只能把指针本身拷贝一份，这是非常危险的。因为2个以上的指针指向同一个对象时容易引发一个内
		 存多次释放，造成内存泄漏。所有对操作符的操作都要重载这些操作符。
4-6. 相对还有很多联系，比如语句之类的，相似度还是非常高的

## 2016 / 1 / 26

1. 通过变量名直接引用变量，系统直接完成变量名与其存储地址间的转换，称为变量的直接引用 char a;a = 10;
2. 在指针没有指向确定地址时不要对其进行赋值操作 char *p;*p = 10;//这是错误的
3. 用例1：swap(a,b)方法，如果没有指针ab的值交换不过来，即在这个函数内部根本无法改变外部的实参
4. 指针分类，一种类型的指针指向同一种类型的变量(在读取指针所指的值时是根据类型长度来读数据的)

在虚拟机下启动docker服务: service docker start
导入mnode_build.tar资源包: docker load < /mnt/cdrom/mnode_build.tar
运行服务器: docker run -p 8080:8080 -p 3000:3000 --rm -ti --privileged=true（这个参数解决CentOS7权限问题） -v /mnt/cdrom/dd-logic:/data/code mnode:build /bin/bash
cd /data/code
npm install --no-bin-links
node test.js启动服务器

ssh://git_mdh@120.26.215.163:9989/data/git/zg/server/game-server.git

## Node.js

Node.js是一套用来编写高性能网络服务器的JavaScript工具包

服务器
1. 物理(独立)服务器(托管主机)
2. 虚拟服务器(将一台独立的物理服务器逻辑分割,但硬件资源共享,服务器间性能互相影响)
3. vps服务器(虚拟主机的一种，但硬件资源独立，服务器间性能互不影响)
4. 云服务器(ECS)


云主机
1. 注册用户
2. 在线支付
3. 购买云服务器，实时开通。开通后登录用户管理区
4. 云服务器管理
5. 管理
6. 预装操作系统，可以选择Windows 2008、Windows 2012、Cent OS 6.5等操作系统，系统安装需要10~25分钟，系统安装完成后就可以通过远程连接进行其他应用操作


云平台(环境相对完善的服务器平台)
heroku

gulp工具
1. 安装node(依赖node运行时) node -v
2. npm全局安装gulp(npm install -g gulp) gulp -v
3. 将gulp安装到项目本地(npm install --save-dev gulp)
4. 安装依赖(npm install gulp-jshint.........)
5. 新建gulpfile文件(放入项目根目录中)
5.5 新建package.json文件gulp init命令

6. gulp只有5个方法: task,run,watch,src,dest
    task任务执行体(逻辑)
    run运行任务
    watch监听操作(文件变化)
    src读文件
    dest写文件
var gulp = require('gulp'), // 必须先引入gulp插件
    del = require('del'),  // 文件删除
    sass = require('gulp-sass'), // sass 编译
    cached = require('gulp-cached'), // 缓存当前任务中的文件，只让已修改的文件通过管道
    uglify = require('gulp-uglify'), // js 压缩
    rename = require('gulp-rename'), // 重命名
    concat = require('gulp-concat'), // 合并文件
    notify = require('gulp-notify'), // 相当于 console.log()
    filter = require('gulp-filter'), // 过滤筛选指定文件
    jshint = require('gulp-jshint'), // js 语法校验
    rev = require('gulp-rev-append'), // 插入文件指纹（MD5）
    cssnano = require('gulp-cssnano'), // CSS 压缩
    imagemin = require('gulp-imagemin'), // 图片优化
    browserSync = require('browser-sync'), // 保存自动刷新
    fileinclude = require('gulp-file-include'), // 可以 include html 文件
    autoprefixer = require('gulp-autoprefixer'); // 添加 CSS 浏览器前缀

服务端

多进程与多线程

多进程：
1. 进程是具有一定独立功能的程序，关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
2. 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响
3. 进程切换时耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程
4. 进程量大，进程切换次数过多，导致CPU资源使用效率低，每个进程的地址空间是独立的，很多空间中重复的数据，所以内存使用效率低，进程切换由于内核完成，占用CPU资源。

多线程：
1. 线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮
2. 多线程的意义在于一个应用程序（进程）中，有多个执行部分可以同时执行，操作系统并没有将多个线程看做多个独立的应用来实现，而是作为进程来调度和管理以及资源分配
3. 而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量
4. 线程间共享进程数据，每个线程响应一个请求，线程切换不可避免（切换量级比较轻量），同一进程的线程可以共享进程的诸多资源，对内存的需求较之进程有很大下降，读可以共享，写不可以共享
5. 线程快速切换时会带来线程抖动，多线程会导致服务器不稳定


多线程与多进程总结：
1. 多进程方式中服务器对一个客户要使用一个进程来提供服务，由于在操作系统中，生成一个进程需要进程内存复制等额外的开销，这样在客户较多时的性能就会降低。为了克服这种生成进程的额外开销，可以使用多线程方式或异步方式。
2. 在多线程方式中，使用进程中的多个线程提供服务， 由于线程的开销较小，性能就会提高。
3. 不需要任何额外开销的方式还是异步方式，它使用非阻塞的方式与每个客户通信，服务器使用一个进程进行轮询就行了
4. 多个线程位于同一个进程内，可以访问同样的内存空间，因此存在线程之间的影响，并且申请的内存必须确保申请和释放。对于服务器系统来讲，由于它要数天、数月甚至数年连续不停的运转，一点点错误就会逐渐积累而最终导致影响服务器的正常运转，因此很难编写一个高稳定性的多线程服务器程序。
5.  多进程方式的优势就在于稳定性，因为一个进程退出的时候，操作系统会回收其占用的资源，从而使它不会留下任何垃圾。即便程序中出现错误，由于进程是相互隔离的，那么这个错误不会积累起来，而是随着这个进程的退出而得到清除
6. 一个进程或线程响应多个请求，不需要任何额外开销的，性能最高，占用资源最少。但也有问题一但进程或线程出错就会导致整个服务器的宕机。

服务器工作过程：
1. 首先我们客户端发送一个请求到Web服务器，请求首先是到网卡。
2. 网卡将请求交由内核空间的内核处理，其实就是拆包了，发现请求的是80端口。
3. 内核便将请求发给了在用户空间的Web服务器，Web服务器接受到请求发现客户端请求的index.html页面。
4. Web服务器便进行系统调用将请求发给内核。
5. 内核发现在请求的是一页面，便调用磁盘的驱动程序，连接磁盘。
6. 内核通过驱动调用磁盘取得的页面文件。
7. 内核将取得的页面文件保存在自己的缓存区域中便通知Web进程或线程来取相应的页面文件。
8. Web服务器通过系统调用将内核缓存中的页面文件复制到进程缓存区域中。
9. Web服务器取得页面文件来响应用户，再次通过系统调用将页面文件发给内核。
10. 内核进程页面文件的封装并通过网卡发送出去。
11. 当报文到达网卡时通过网络响应给客户端

客户端向Web服务请求过程：在这个过程中，有两个I/O过程，一个就是客户端请求的网络I/O，另一个就是Web服务器请求页面的磁盘I/O

用户请求-->
送达到用户空间-->
系统调用-->
内核空间-->
内核到磁盘上读取网页资源-->
返回到用户空间-->响应给用户


## 2016/9/28/

windows下的多线程编程环境
MinGW工具包
pthread第三方线程库(Pre-built目录下的lib与include)

1. 将Pre-built中lib目录下的文件copy到MinGW下的lib中

    libpthreadGC2.a
    libpthreadGCE2.a
    ......
    (编译时需要链接这些文件-lpthreadGCE2)
2. 将Pre-built中include目录下的文件copy到MinGW下的include中

3. 将Pre-built中dll目录下的文件copy到系统目录Windows下或执行文件(.cpp)的同级目录下

4. 编译g++ Thread.cpp -oThread -lpthreadGCE2

5. 不知道什么原因编译能过但运行时报无法链接libstdc++-6.dll文件(将Thread.cpp文件与关联的.dll文件放入同一文件夹下解决了这个问题)


## 2016/9/29/

多线程与异步的相似性(异步操作不消耗cpu资源,多线程消耗cpu资源但比多进程消耗少)


C++通过socket编程实现服务端与客户端的通讯，（调试的时候请先运行服务端程序在运行客服端，一定要加载库函数ws2_32.lib）

注意: 

1. 客户端与服务器都要包含winsock2.h头文件与ws2_32.lib库

#include "winsock2.h"
#pragma comment(lib, "ws2_32.lib");

2. 编译环境

window系统控制台下用minGW编译

3. 编译文件

直接编译:
g++ Server.cpp -o server
g++ Client.cpp -o client
报undefined reference to `closesocket@4'等一系列错误

注：编译时需要链接ws2_32.lib库，指定链接到socket库
g++ Server.cpp -lws2_32 -o server
g++ Client.cpp -lws2_32 -o client
编译通过

C++兼容之前的标准。办法是在编译时加上参数 -std=c++0x

1.目前C/C++编译器最流行的就是gcc与g++
2.安装编译器，在windows下使用gcc与g++是通过安装MinGW实现的
3.MinGW(Minimalist GNU on Windows)安装后可以使用很多GNU(Linux下一个著名的项目)工具，包含了gcc/g++/gdb等工具(MinGW\lib下有标准库;MinGW\include下有头文件)
4.把MinGW文件夹放入C盘根目录
5.命令执行时('gcc'不是内部或外部命令)，会在当前目录下查找名为gcc可执行文件，如果查不到就在系统环境变量path记录的路径里寻找gcc可执行文件（1.可以用绝对路径来调用gcc可执行文件;2.把gcc路径写入系统环境变量中）,环境变量设置完后要重起windows
6.gcc虽然可以编译C++代码，但是不能进行C++的连接函数库操作，所以针对C++代码一般使用g++编译
7.在cmd下编译时要在当前C/C++文件目录路径下进行
8.Ctrl + B执行上一次的编译命令;Ctrl+Shift+B选择执行哪个命令(C++ Single File编译/C++ Single File - Run运行)

//2015/10/23
1.目前的Linux源码会把模块相关的文档说明保存在源码目录的documention的文件夹下，如果待分析的模块没有文档说明，这多少会增加定位关键源码文件的难度，但是不会导致我们找不到我们要分析的源码.
2.Linux内核结构
	a.系统调用接口(SCI):open,read,write等系统调用
	b.进程管理(PM):创建进程,删除进程,调度进程等
	c.内存管理(MM):内存分配,管理等
	d.虚拟文件系统(VFS):为多种文件系统提供统一的操作接口
	e.网络协议栈:提供各种网络协议
	f.CPU架构相关代码(Arch):为的是提高移植性
	g.设备驱动程序(DD):各种设备驱动，占到内核的70%左右代码
//2015/10/24
1.Linux源码目录
	a.Arch:存放处理器相关代码，下设子目录对应具体的cpu，每个子目录有boot（系统引导）,mm（存储管理）,以及kernel（系统调用）三个子目录
	b.Include:内核所需的大部分头文件目录，与平台无关的在include/linux子目录下，与平台相关的则放在include相应的子目录中
	c.fs:存放各种文件系统的实现代码
	d.init:init子目录包含核心的初始化代码（非系统引导代码）,其中包含两个文件main.c和version.c，可以用来研究核心如何工作
	e.ipc:包含核心进程间的通信代码
	f.kernel:包含内核管理的核心代码。与硬件相关代码放在arch/*/kernel目录下
	g.mm:包含了所有的内存管理代码。与硬件相关的内存管理代码位于arch/*/mm目录下
	h.scripts:包含用于配置核心的脚本文件
	i.lib:包含了核心的库代码，与硬件相关的库代码被放在arch/*/lib/目录下

//2015/10/26
1.引用传参是C++的特性，C语言不支持引用传参
2.但实际在使用时候C语法却可以使用引用传参

//2015/10/27
1.要使用C++的多态必须要使用虚函数
2.必须要使用指针或引用
3.一个类只有有了虚函数才会有一张虚函数表，多态就是通过这张表实现的
4.对象间的赋值并不能把虚表从一个类对象赋值给另一个对象(对角访问虚函数并没有通过虚函数表)

//2016/7/26
c++中typedef用法
1. 复杂声明替换
	('左右法则'解析复杂声明)
	从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
	int (*func)(int *p);
	首先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int*类型的形参，返回值类型是int。
	int (*func[5])(int *);
	func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int*类型的形参，返回值类型为int。

2. 类型替换(处理支持数据类型不同的平台)
	typedef long double REAL;// 长整型
	typedef double REAL;// 不支持长整型平台
	typedef float REAL;// 不支持double型平台

3. struct声明
	c语言中声明struct新对象时需要struct关键字(如: struct 结构名 对象名)
	struct PointStruct {
		int x;
		int y;
	};
	struct PointStruct p;
	使用typedef简化操作：
	typedef struct PointStruct {
		int x;
		int y;
	}POINT;
	// 声明结构体新对象
	POINT p;

4. 与宏不一样，定义了一种类型的新别名，不是简单的字符串替换

// 2016/8/9/

向前说明：
class A;
class B;
与头文件引用：
include "A.h"
include "B.h"
区别：
向前说明一般用于不完全类型引用(incomplete type),
不完全类型是指：
	
	包括那些类型信息没不完整的对象类型以及空类型(void)，前者是指大小(size),内存布局(layout),对齐方式都还未知的模糊类型

用法：
A.h头文件
````
class A
{......};

````
B.h头文件
````

// A类的向前声明
class A;

class B
{
	private:
		// 以下A都是不完整类型
		A *ap;
		int func(const A &a, const A &a2);
};

B.h头文件并没有包含A的头文件，但可以通过编译，因为B.h头文件只用到了A类的指针与引用，而在C++标准中定义指针与引用时不需要类的完整信息
当通过指针或引用调用成员方法时需要类的完整信息

不完全类型只能以有限方式使用，不能定义该类型的对象，不完全类型只能用于定义指向该类型的指针及引用，或者用于声明(而不是定义)使用该类型作为形参类型或返回类型的函数。

成员函数不占类对象的大小，所以c++编译器还是可以确定对象的大小。

// 2016/9/27/

c语言的static用法

全局变量------存放在内存的静态存储区(在整个项目工程中有效)
静态全局变量------存放在内存的静态存储区(只在定义它的文件中有效)
局部变量------存放在内存的栈区(在定义它的块内有效，执行完后会被释放)
静态局部变量------存放在内存的静态存储区(只在定义它的函数中有效，只是程序只分配一次内存，函数执行完后该变量不会释放)

c++的static用法
一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染
(类的静态数据成员在类内声明，在类外初始化)

extern与static与全局变量区别

1. 如果a.h中有 int a=10;
	t1.cpp和t2.cpp同时include "a.h"则编译不成功，因为a重复定义。

2. 如果 a.h中是 static int a=10;
	则可以，因为t1.cpp和t2.cpp中的a只是名字相同，地址空间不同。

3. 如果a.h中是 extern int a;并且在a.cpp中 int a = 10;(或extern int a = 10;)
	则t1.cpp和t2.cpp中的a指向同一个地址空间。

4. 如果在.cpp文件中定义了const int a = 10;(全局const)则等价与static const int a = 10;


在头文件中定义全局变量，如果该头文件不被任何.c或者.cpp中包含的话，该变量的定义是没有意义的，即使加了extern 关键字。因为在变量定义中，extern关键字是不起作用的，extern只用作声明。
编译器在编译时，是不管头文件的，只有在预处理时会include头文件中的内容，也就是把头文件中的内容全盘粘贴过来。因此，如果你只是在头文件中定义变量，而不include头文件，这时，编译器无论是在预处理阶段，还是在链接阶段，直接无视头文件的存在(链接器只会在.c/.cpp生成的目标文件(.o)中查找变量名）。这样一来，头文件中定义的变量也就形同虚设，完全没有意义可言。
因此VS链接时也就会出现无法解析的外部命令了。


局部变量的用法

1. C++中函数是可以返回局部变量的，函数一般的操作是把局部变量复制后返回给调用者。

2. 不能返回局部变量的是指针和局部变量的引用，因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。返回局部变量的引用也是绝	对不可以的。 引用只是变量的一个别名，变量本体都不存在了，引用当然也没有任何意义。 

3. 如果是堆空间，可以返回，即在函数中用new申请的空间，是可以返回的。
	但是一般的情况下，好的风格是： 尽量在同一个作用域内成对使用new   和delete，（也即不要返回堆空间），因为如果不是这样，会是你的函数的接口变的不够灵活， 试想每个调用你的函数的人还需要记得去delete掉你在函数中new的堆空间， 否则就会造成内存泄露。

4. 函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型

5. 字符串常量，存放在只读数据段，把该字符串常量存放的只读数据段的首地址赋值给了局部变量的指针后是可以返回出去的(只读数据段不会释放)

6. 如果函数内声明了一个局部对象，而该对象的类实现了拷贝构造函数，则可以将该局部对象作为返回值返回，反之则失败

/**
 * C/C++编译
 */

+ 对源代码进行编译时，第一个阶段就是进行预处理。以#开头的都是预处理指令(#include/#define)，都会被预处理器处理掉
+ 代码不是直接被编译，而是先被预处理器进行修改
	1. #include    #define  预处理指令的替换
	2. 删除注释

+ #define与typedef区别

#define D int*;(简单字符替换)
typedef int* T;(类型替换)

int main() {
	
	D p1, p2;
	T p3, p4;

	return 0;
}

D p1, p2语句的结果为:
int *p1;
int p2;

T p3, p4语句的结果为:
int *p3;
int *p4;

可以认为：typedef是将已存在的类型，包装成新的原子类型

C/C++头文件中一般存放如下内容:
1、类的声明
2、结构的声明
3、内敛函数的定义 和声明。内敛函数整体都放在头文件中。这样包含它的每个源文件才知道怎样展开。
4、模板
5、#define 宏 和  const 常量


+ 指针作用：
1. 通过动态申请的内存是匿名的，没有名字，只能通过指向这块内存的指针去使用
	new
    malloc();
    realloc();
    calloc();
2. 用函数交换2个变量的值

+ 对象的定义

class A {
	
};

A a;(如果在全局区的直接定义)
在内存的静态存储区上分配对象。通常会影响编译出来的程序的大小。

A a;(如果在函数中的直接定义)
则在栈上分配对象。分配和释放速度非常快，但栈空间相对有限，对于大量的对象，有可能造成栈溢出。
直接调用类的析构释放资源

A *a;
这只是定义了一个指针，没有创建对象也没有分配空间

A *a = new A();
出来的对象在堆中分配，分配释放速度较慢，但堆内存空间较大，可以充分利用内存。
需要delete a;释放资源