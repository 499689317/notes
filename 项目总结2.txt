// 
// 年度总结
// 

// 
// 项目初期构思角色关系图解
// 

1.人物(player and enemy):
	base:{
		运动逻辑：{上，下，左，右，斜上左，斜上右，斜下左，斜下右}
		运动动画：{上，下，左，右，斜上左，斜上右，斜下左，斜下右}
		运动状态：{UP,DOWN,LEFT,RIGHT,UPLEFT,UPRIGHT,DOWNLEFT,DOWNRIGHT}
		属性状态：{DIE(是否死亡bool),attackRange(攻击范围numbel),bloodBar(人物血条object,血条可以用单独的一个类，可以被人物代理(实现一些代理方法来管理)),damageValue(当前伤害值numbel),speedValue(当前的速度numbel)}
		自身检测能力：UP --> 上(动作) --> 上(动画)
					  DOWN --> 下(动作) --> 下(动画)
					  LEFT --> 左(动作) --> 左(动画)
					  RIGHT --> 右(动作) --> 右(动画)
					  UPLEFT --> 左上(动作) --> 左上(动画)
					  UPRIGHT --> 右上(动作) --> 右上(动画)
					  DOWNLEFT --> 左下(动作) --> 左下(动画)
					  DOWNRIGHT --> 右下(动作) --> 右下(动画)
	}
	player: public base{
		战士：Soldier
		法师：Rabbi
		猎人：Hunter
	}
	enemy: public base{
		A:
		B:
		C:
	}
+------------------------------------------++--------------------------------------++------------------------------------------+
|	  		战士(Soldier)                  ||           法师(Rabbi)                ||           猎人(Hunter)                   |
|     1.战士是否有特别任务剧情             ||     1.法师是否有特别剧情             ||      1.猎人是否有特别剧情                |
|     2.Soldier的技能特点(SKILL_SOLDIER)   ||     2.Rabbi的技能特点(SKILL_RABBI)   ||      2.Hunter的技能特点(SKILL_HUNTER)    |
|     3.Soldier的属性特点(PROPERTY_SOLDIER)||     3.Rabbi的属性特点(PROPERTY_RABBI)||      3.Hunter的属性特点(PROPERTY_HUNTER) |
|     4.Soldier的速度特点(SPEED_SOLDIER)   ||     4.Rabbi的速度特点(SPEED_BABBI)   ||      4.Hunter的速度特点(SPEED_HUNTER)    |
|     5.Soldier的攻击加成(DAMAGE_SOLDIER)  ||     5.Rabbi的攻击加成(DAMAGE_BABBI)  ||      5.Hunter的攻击加成(DAMAGE_HUNTER)   |
+------------------------------------------++--------------------------------------++------------------------------------------+
1.所有的角色都是继承自基类base
2.所有的角色都在基类base的基础上有自已的拓展
3.继承自base类的所有子类都具有检索功能(检索功能应当与人物一起绑定-----人物自已拥有检索其它角色的能力)

[js前端]：
2种方式渲染页面
	1.使用h5中的div与css

	function Layer(doc){
		this._div = doc.createElement('div');
		this._sty = this._div.style;
		//通过定义接口或直接赋值来间接或直接设置div的css属性
		this._sty.position = 'absolute';
		this._sty.overflow = 'hidden';
	}

	Layer.prototype.setX = function (v) {
		this._sty.left = v + 'px';
	}

	Layer.prototype.setY = function (v) {
		this._sty.top = v + 'px';
	}

	Layer.prototype.setWidth = function (v) {
		this._sty.width = v + 'px';
	}

	Layer.prototype.setHight = function (v) {
		this._sty.hight = v + 'px';
	}

	2.使用canvas渲染
	直接获取上下文getContent('2d')

// 
// 战斗场景分层
// 

	地图层
	中间层
	人物层
	顶层
	1>. 地图层为第0层
	2>. 中间层为第1层，buff效果，技能特效
	3>. 人物层为第2层，分为4个子层：
								精灵层，攻击效果层，血条层，阴影层
								精灵层：sprite所处的层
								攻击效果层：攻击的效果展示
								血条层：血条放置层
								阴影层：人物脚底部份的阴影
	4>. 顶层为第3层，特效处理
2. 技能脚本：将角色技能分脚本写，技能逻辑--
	技能脚本管理器：根据不同角色的id获取角色部分属性，根据属性返回一个合理的技能
3. 人物管理机制：定义一些委托数据与委托类，能正确反应该角色的性格特征
4. 状态机：人物的每一种状态都有一种逻辑与其对应，根据传入的角色id获取当前状态下的角色的逻辑数据，返回这个逻辑
	状态机管理器：能够根据状态来选择使用合理的状态机，在角包切换状态时能处理之前状态的清理工作，也能及时切入下一状态
5. 数据模型：初始化角色当前所有的数据，并能很好处理数据间的传值


// 
// 战斗角色的技能
// 

1. 添加人物技能：
	-将人物普通攻击当成技能释放
	-技能与技能间成为互斥关系
	-人物与人物间的技能不相关

2. 技能脚本：
	1. 技能管理器：SkillManage
	2. 技能文件：skill1,skill2,skill3
	SkillManage:
		挂到人物身上，当人物需要技能时候从SkillManage中取出，如果技能管理不挂到人物中，比较难管理技能
		SkillManage中需要提供一个提取技能的方法：getSkill,在getSkill中返回的技能应该是当前最合适的(其中包含了大量了过滤判断，取出最合适的技能)
	skill1,skill2,skill3....每一个具体的技能对象
	// 技能最好能分文件写
	skill1 = {

	}
	skill1.check = function() {

		// 检测当前技能是否满足释放
		// 检测优先级下技能释放的可能性

	}
	skill1.create = function() {

		// 创建该技能
		// ui视图创建
		// 数据创建
		// 返回一个技能对象

	}
	skill1.destry = function() {

		// 如果技能释放完，释放该技能空间
		// 如果技能被别人打断，释放该技能空间
	}

// 2015 / 12 / 15
4. js中异步操作：setTimeOut可以在不阻塞线程的基础上实现异步操作，但对于时间的把控并不可控
	在js中开子线程对于程序兼容性影响比较大，一般不推荐使用
	尽量使用异步回调的方式解决程序中的一些问题

// 2015 / 12 / 16
5. 在检测位置间关系时，如果不会出现开根号等无限小数，则不需要使用Math.floor或者Math.round方法，这俩个方法一般只用于粗略判断。对于精确定位精灵位置没有实
	际应用价值

// 2015/ 12 / 17
1. 寻路算法是准确的，(只是在定位精灵位置时出现浮点数值，最终根据Math.floor方法进行位置转换时出现误差)
2. 如果不使用Math.floor方法对精灵位置进行误差取整的话，寻路算法pathLogic将会无限不能寻路，与浮点数关系非常大(不兼容浮点数)
3. 需要设计更加准确的方法调整精灵移动与战斗中的位置

// 2015/ 12 / 22
1. js中数组pop一个元素后会删除该元素

// 2015/ 12 / 24
1.使用定时器的优点：
	统一管理一个经常调用的方法如：此方法用于递归，一个逻辑的循环。。。。
// 2015 / 12 / 25

1. 代理charles
	1>. 将线上玩吧前端代码代理到自已本地（本地代码）
		map from (线上前端路径) ----- map to (本地前端路径)
	2>. 将线上服务器（后端）代码代理到本地
		map from  （线上服务器路径/*） map to (本地服务器路径/)



项目总结：

	1.> 帧动画切换
		在任一时该能否灵活切换所需要的动画，
		是否能够将任一动画置于任一指定位置播放
	2.> 地图是否会越界
		角色移动到地图边界时，地图应该停止移动
		地图要在角色移动到任一位置前先渲染完成
	3.> 角色移动
		角色的站位是否符合预期
		角色的寻路路线是否符合预期
		当俩个阵容的角色一起移动，寻路的路线是否符合预期
		过滤不需要寻路时的寻路(死循环)
		当寻找到对方时的站位是否符合预期
		俩个角色的攻击距离是否符合预期

项目战斗系统：
	1. 角色监听事件，当角色进入怪物区，重新对所有人物定位
	2. 角色选择一个最优点到达(目标点)
	3. 怪物到达目标点周围的站位点

// 
// 项目中一次技能释放的流程
// 

1. skill manage 
2. skill
3. 
4. 进入技能状态
5. 获取技能管理器
6. 技能管理器选择一个合适的技能
7. 开始释放技能
8. 角色的动画
9. 技能的动画
10. 角色动画完成后回调：判断此时下一个最合适的技能？
11. 技能动画完成后回调：判断此时所有敌人是否死亡？
	如果所有敌人都死了，进入捡取掉落状态
	如果还有敌人没有死，选择下一个合适的敌人，继续进入skill状态，直到所有敌人死亡

技能模块中
    1. 使有action时如何预判时间，近距离与远距离在时间一样的情况下速度不同

// 2016 / 1 / 19
gulp 配置0.12.1版本node.js
gulp中常用的node.js的stream API:

	gulp.task()
	gulp.src()//读入流
	gulp.dest()//写入流
	gulp.watch()

// 2016 / 1 / 26
1. 通过变量名直接引用变量，系统直接完成变量名与其存储地址间的转换，称为变量的直接引用 char a;a = 10;
2. 在指针没有指向确定地址时不要对其进行赋值操作 char *p;*p = 10;//这是错误的
3. 用例1：swap(a,b)方法，如果没有指针ab的值交换不过来，即在这个函数内部根本无法改变外部的实参
4. 指针分类，一种类型的指针指向同一种类型的变量(在读取指针所指的值时是根据类型长度来读数据的)

1. 目前项目的进展
	
	1-1. 到今天为止，项目已经有了一个稳定的版本，人物切换技能，人物智商，资源的加载等等都做了一个妥善的处理
	1-2. 技能动画的处理也相对比较妥当，但有3个技能还有一些问题：1.战士的剑刃风暴 2.法师的暴风雪 3.猎人的多重射击
	1-3. 项目也进入了一个新的阶段：
		人物模型
		数据模型
		人物状态机
		技能脚本
		场景的各个层级
		人物的各个层级

2. 对项目未来的一个规划
	
	2-1. 在原来的项目中继续完善，分别从性能与视觉上做到更好
	2-2. 加入游戏的玩法
	2-3. 与服务器对接
	2-4. 对游戏中未确定的东西进行补充，比如数据模型，技能脚本，人物模型等等
	2-5. 把项目尽量往灵活性方向写，根据第一个项目的经验，这个项目后期也会出现大量修改

3. 经过一段时间对编程的感触
	
	3-1. 理论上所有程序上的问题都是可以解决的，所以编程倒并不是一件因难的事
	3-2. 编写程序相对来说要比其它行业好一些，不需要跟人打太多交道
	3-3. 任何语言的东西都是相通的，一般熟练了一种语言后学习其它的都会比较快了
	3-4. 编程其实是比谁注意力更集中的工作，一般来说一个合格的程序员每天都能写500行高质量代码

4. 自已对编程的一些想法

	4-1. js与其它语言的差异性还是非常明显的
	4-2. 在js中构造函数相对比较随意，一般一个构造函数可以匹配所有实例，但一般在C++中一个类利用函数重载可以有多个构造函数，
		 构造函数与实例严格匹配或者最佳匹配：
		 Thing()
		 Thing(int a)
		 Thing(int a, int b)
		 Thing(int a= 0, int b = 0)
		 这些构造函数间在任意组合的过程很容易产生二义性
	4-3. js依靠弱类型可以很轻松避免父子关系带来的二义性，但在C++中这个严格区分的，因为C++中为了能实现对未来代码的拓展加入了一个叫动态绑定的机制，
		 即程序在编译时并不知道要调用哪一个方法，只有在运行时才能确定真正调用的是谁。这也是C++中非常重要的一个特性多态的原理：用一个父类的指针指
		 向一个子类的对象时，这个指针可以调用父类及子类所有方法。并且这些方法一般会声明为虚函数，此时指针在指向这些方法时，编译不能确定是父类还
		 是子类，只有在运行时才知道
	4-4. js在传参这一块依然与其它语言有一定差异，在C++中传参有三种方式，第一种比较常见的传指针，第二种传值，第三种传引用。一般来说传指针与传值
		 传参是单向传递的，形参与实参是互不影响的，第三种传引用与js中的传引用也有一定区别，C++中引用使用&符号，它只代表另一个变量的一个别名，没有
		 其它任何意义，当变量改变时，所有引用都是改变的，所以传引用是双向传递。并且在拷贝构造函数中是一定要传引用的，否则后果不堪设想。
	4-5. js功能强大与直接使用操作符一样，但是在其它语言这是非法的，在C++中你可以对一些基本类型使用 == 操作符或 = 赋值操作符等等，但是这涉及到c++的
		 一个知识点深拷贝，当对一个指针进行这些操作时 = 号只能把指针本身拷贝一份，这是非常危险的。因为2个以上的指针指向同一个对象时容易引发一个内
		 存多次释放，造成内存泄漏。所有对操作符的操作都要重载这些操作符。
	4-6. 相对还有很多联系，比如语句之类的，相似度还是非常高的

5. 对自已过去的总结与对未来的规划

    以上说了一些感触与想法，也说了一些计划。在这里对这些总结到一起其实也就是抓紧时间写代码，快点解决问题。但我想说的是对未来的规划，我一直觉得规
    划相对来说比较重要，首先对现在这个项目，进度很重要，做到不要拖进度。其次把能做的做到最好，即使没有一个标准也要最优解决。以上我觉得是我当前急需
    要做好的一些方面。