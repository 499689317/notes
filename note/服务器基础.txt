ssh://git_mdh@120.26.215.163:9989/data/git/zg/server/game-server.git
// Node.js
//////////////////
////////////////////
Node.js是一套用来编写高性能网络服务器的JavaScript工具包

服务器
1. 物理(独立)服务器(托管主机)
2. 虚拟服务器(将一台独立的物理服务器逻辑分割,但硬件资源共享,服务器间性能互相影响)
3. vps服务器(虚拟主机的一种，但硬件资源独立，服务器间性能互不影响)
4. 云服务器(ECS)


云主机
1. 注册用户
2. 在线支付
3. 购买云服务器，实时开通。开通后登录用户管理区
4. 云服务器管理
5. 管理
6. 预装操作系统，可以选择Windows 2008、Windows 2012、Cent OS 6.5等操作系统，系统安装需要10~25分钟，系统安装完成后就可以通过远程连接进行其他应用操作


云平台(环境相对完善的服务器平台)
heroku

///////////////////
gulp工具
1. 安装node(依赖node运行时) node -v
2. npm全局安装gulp(npm install -g gulp) gulp -v
3. 将gulp安装到项目本地(npm install --save-dev gulp)
4. 安装依赖(npm install gulp-jshint.........)
5. 新建gulpfile文件(放入项目根目录中)
5.5 新建package.json文件gulp init命令

6. gulp只有5个方法: task,run,watch,src,dest
    task任务执行体(逻辑)
    run运行任务
    watch监听操作(文件变化)
    src读文件
    dest写文件



var gulp = require('gulp'), // 必须先引入gulp插件
    del = require('del'),  // 文件删除
    sass = require('gulp-sass'), // sass 编译
    cached = require('gulp-cached'), // 缓存当前任务中的文件，只让已修改的文件通过管道
    uglify = require('gulp-uglify'), // js 压缩
    rename = require('gulp-rename'), // 重命名
    concat = require('gulp-concat'), // 合并文件
    notify = require('gulp-notify'), // 相当于 console.log()
    filter = require('gulp-filter'), // 过滤筛选指定文件
    jshint = require('gulp-jshint'), // js 语法校验
    rev = require('gulp-rev-append'), // 插入文件指纹（MD5）
    cssnano = require('gulp-cssnano'), // CSS 压缩
    imagemin = require('gulp-imagemin'), // 图片优化
    browserSync = require('browser-sync'), // 保存自动刷新
    fileinclude = require('gulp-file-include'), // 可以 include html 文件
    autoprefixer = require('gulp-autoprefixer'); // 添加 CSS 浏览器前缀
///////////////////




服务端

多进程与多线程

多进程：
1. 进程是具有一定独立功能的程序，关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
2. 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响
3. 进程切换时耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程
4. 进程量大，进程切换次数过多，导致CPU资源使用效率低，每个进程的地址空间是独立的，很多空间中重复的数据，所以内存使用效率低，进程切换由于内核完成，占用CPU资源。

多线程：
1. 线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮
2. 多线程的意义在于一个应用程序（进程）中，有多个执行部分可以同时执行，操作系统并没有将多个线程看做多个独立的应用来实现，而是作为进程来调度和管理以及资源分配
3. 而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量
4. 线程间共享进程数据，每个线程响应一个请求，线程切换不可避免（切换量级比较轻量），同一进程的线程可以共享进程的诸多资源，对内存的需求较之进程有很大下降，读可以共享，写不可以共享
5. 线程快速切换时会带来线程抖动，多线程会导致服务器不稳定


多线程与多进程总结：
1. 多进程方式中服务器对一个客户要使用一个进程来提供服务，由于在操作系统中，生成一个进程需要进程内存复制等额外的开销，这样在客户较多时的性能就会降低。为了克服这种生成进程的额外开销，可以使用多线程方式或异步方式。
2. 在多线程方式中，使用进程中的多个线程提供服务， 由于线程的开销较小，性能就会提高。
3. 不需要任何额外开销的方式还是异步方式，它使用非阻塞的方式与每个客户通信，服务器使用一个进程进行轮询就行了
4. 多个线程位于同一个进程内，可以访问同样的内存空间，因此存在线程之间的影响，并且申请的内存必须确保申请和释放。对于服务器系统来讲，由于它要数天、数月甚至数年连续不停的运转，一点点错误就会逐渐积累而最终导致影响服务器的正常运转，因此很难编写一个高稳定性的多线程服务器程序。
5.  多进程方式的优势就在于稳定性，因为一个进程退出的时候，操作系统会回收其占用的资源，从而使它不会留下任何垃圾。即便程序中出现错误，由于进程是相互隔离的，那么这个错误不会积累起来，而是随着这个进程的退出而得到清除
6. 一个进程或线程响应多个请求，不需要任何额外开销的，性能最高，占用资源最少。但也有问题一但进程或线程出错就会导致整个服务器的宕机。

服务器工作过程：
1. 首先我们客户端发送一个请求到Web服务器，请求首先是到网卡。
2. 网卡将请求交由内核空间的内核处理，其实就是拆包了，发现请求的是80端口。
3. 内核便将请求发给了在用户空间的Web服务器，Web服务器接受到请求发现客户端请求的index.html页面。
4. Web服务器便进行系统调用将请求发给内核。
5. 内核发现在请求的是一页面，便调用磁盘的驱动程序，连接磁盘。
6. 内核通过驱动调用磁盘取得的页面文件。
7. 内核将取得的页面文件保存在自己的缓存区域中便通知Web进程或线程来取相应的页面文件。
8. Web服务器通过系统调用将内核缓存中的页面文件复制到进程缓存区域中。
9. Web服务器取得页面文件来响应用户，再次通过系统调用将页面文件发给内核。
10. 内核进程页面文件的封装并通过网卡发送出去。
11. 当报文到达网卡时通过网络响应给客户端

客户端向Web服务请求过程：在这个过程中，有两个I/O过程，一个就是客户端请求的网络I/O，另一个就是Web服务器请求页面的磁盘I/O

用户请求-->
送达到用户空间-->
系统调用-->
内核空间-->
内核到磁盘上读取网页资源-->
返回到用户空间-->响应给用户
