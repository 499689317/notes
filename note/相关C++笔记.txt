

/********/
1.目前C/C++编译器最流行的就是gcc与g++
2.安装编译器，在windows下使用gcc与g++是通过安装MinGW实现的
3.MinGW(Minimalist GNU on Windows)安装后可以使用很多GNU(Linux下一个著名的项目)工具，包含了gcc/g++/gdb等工具(MinGW\lib下有标准库;MinGW\include下有头文件)
4.把MinGW文件夹放入C盘根目录
5.命令执行时('gcc'不是内部或外部命令)，会在当前目录下查找名为gcc可执行文件，如果查不到就在系统环境变量path记录的路径里寻找gcc可执行文件（1.可以用绝对路径来调用gcc可执行文件;2.把gcc路径写入系统环境变量中）,环境变量设置完后要重起windows
6.gcc虽然可以编译C++代码，但是不能进行C++的连接函数库操作，所以针对C++代码一般使用g++编译
7.在cmd下编译时要在当前C/C++文件目录路径下进行
8.Ctrl + B执行上一次的编译命令;Ctrl+Shift+B选择执行哪个命令(C++ Single File编译/C++ Single File - Run运行)
/********/
//2015/10/23
1.目前的Linux源码会把模块相关的文档说明保存在源码目录的documention的文件夹下，如果待分析的模块没有文档说明，这多少会增加定位关键源码文件的难度，但是不会导致我们找不到我们要分析的源码.
2.Linux内核结构
	a.系统调用接口(SCI):open,read,write等系统调用
	b.进程管理(PM):创建进程,删除进程,调度进程等
	c.内存管理(MM):内存分配,管理等
	d.虚拟文件系统(VFS):为多种文件系统提供统一的操作接口
	e.网络协议栈:提供各种网络协议
	f.CPU架构相关代码(Arch):为的是提高移植性
	g.设备驱动程序(DD):各种设备驱动，占到内核的70%左右代码
//2015/10/24
1.Linux源码目录
	a.Arch:存放处理器相关代码，下设子目录对应具体的cpu，每个子目录有boot（系统引导）,mm（存储管理）,以及kernel（系统调用）三个子目录
	b.Include:内核所需的大部分头文件目录，与平台无关的在include/linux子目录下，与平台相关的则放在include相应的子目录中
	c.fs:存放各种文件系统的实现代码
	d.init:init子目录包含核心的初始化代码（非系统引导代码）,其中包含两个文件main.c和version.c，可以用来研究核心如何工作
	e.ipc:包含核心进程间的通信代码
	f.kernel:包含内核管理的核心代码。与硬件相关代码放在arch/*/kernel目录下
	g.mm:包含了所有的内存管理代码。与硬件相关的内存管理代码位于arch/*/mm目录下
	h.scripts:包含用于配置核心的脚本文件
	i.lib:包含了核心的库代码，与硬件相关的库代码被放在arch/*/lib/目录下

//2015/10/26
1.引用传参是C++的特性，C语言不支持引用传参
2.但实际在使用时候C语法却可以使用引用传参

//2015/10/27
1.要使用C++的多态必须要使用虚函数
2.必须要使用指针或引用
3.一个类只有有了虚函数才会有一张虚函数表，多态就是通过这张表实现的
4.对象间的赋值并不能把虚表从一个类对象赋值给另一个对象(对角访问虚函数并没有通过虚函数表)

//2016/7/26
c++中typedef用法
1. 复杂声明替换
	('左右法则'解析复杂声明)
	从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
	int (*func)(int *p);
	首先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int*类型的形参，返回值类型是int。
	int (*func[5])(int *);
	func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int*类型的形参，返回值类型为int。

2. 类型替换(处理支持数据类型不同的平台)
	typedef long double REAL;// 长整型
	typedef double REAL;// 不支持长整型平台
	typedef float REAL;// 不支持double型平台

3. struct声明
	c语言中声明struct新对象时需要struct关键字(如: struct 结构名 对象名)
	struct PointStruct {
		int x;
		int y;
	};
	struct PointStruct p;
	使用typedef简化操作：
	typedef struct PointStruct {
		int x;
		int y;
	}POINT;
	// 声明结构体新对象
	POINT p;

4. 与宏不一样，定义了一种类型的新别名，不是简单的字符串替换

// 2016/8/9/

向前说明：
class A;
class B;
与头文件引用：
include "A.h"
include "B.h"
区别：
向前说明一般用于不完全类型引用(incomplete type),
不完全类型是指：
	
	包括那些类型信息没不完整的对象类型以及空类型(void)，前者是指大小(size),内存布局(layout),对齐方式都还未知的模糊类型

用法：
A.h头文件
````
class A
{......};

````
B.h头文件
````

// A类的向前声明
class A;

class B
{
	private:
		// 以下A都是不完整类型
		A *ap;
		int func(const A &a, const A &a2);
};

B.h头文件并没有包含A的头文件，但可以通过编译，因为B.h头文件只用到了A类的指针与引用，而在C++标准中定义指针与引用时不需要类的完整信息
当通过指针或引用调用成员方法时需要类的完整信息

不完全类型只能以有限方式使用，不能定义该类型的对象，不完全类型只能用于定义指向该类型的指针及引用，或者用于声明(而不是定义)使用该类型作为形参类型或返回类型的函数。

成员函数不占类对象的大小，所以c++编译器还是可以确定对象的大小。





// 2016/9/27/

c语言的static用法

全局变量------存放在内存的静态存储区(在整个项目工程中有效)
静态全局变量------存放在内存的静态存储区(只在定义它的文件中有效)
局部变量------存放在内存的栈区(在定义它的块内有效，执行完后会被释放)
静态局部变量------存放在内存的静态存储区(只在定义它的函数中有效，只是程序只分配一次内存，函数执行完后该变量不会释放)

c++的static用法
一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染
(类的静态数据成员在类内声明，在类外初始化)

extern与static与全局变量区别

1. 如果a.h中有 int a=10;
	t1.cpp和t2.cpp同时include "a.h"则编译不成功，因为a重复定义。

2. 如果 a.h中是 static int a=10;
	则可以，因为t1.cpp和t2.cpp中的a只是名字相同，地址空间不同。

3. 如果a.h中是 extern int a;并且在a.cpp中 int a=10;
	则t1.cpp和t2.cpp中的a指向同一个地址空间。


在头文件中定义全局变量，如果该头文件不被任何.c或者.cpp中包含的话，该变量的定义是没有意义的，即使加了extern 关键字。因为在变量定义中，extern关键字是不起作用的，extern只用作声明。
编译器在编译时，是不管头文件的，只有在预处理时会include头文件中的内容，也就是把头文件中的内容全盘粘贴过来。因此，如果你只是在头文件中定义变量，而不include头文件，这时，编译器无论是在预处理阶段，还是在链接阶段，直接无视头文件的存在(链接器只会在.c/.cpp生成的目标文件(.o)中查找变量名）。这样一来，头文件中定义的变量也就形同虚设，完全没有意义可言。
因此VS链接时也就会出现无法解析的外部命令了。


局部变量的用法

1. C++中函数是可以返回局部变量的，函数一般的操作是把局部变量复制后返回给调用者。

2. 不能返回局部变量的是指针和局部变量的引用，因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。返回局部变量的引用也是绝	对不可以的。 引用只是变量的一个别名，变量本体都不存在了，引用当然也没有任何意义。 

3. 如果是堆空间，可以返回，即在函数中用new申请的空间，是可以返回的。
	但是一般的情况下，好的风格是： 尽量在同一个作用域内成对使用new   和delete，（也即不要返回堆空间），因为如果不是这样，会是你的函数的接口变的不够灵活， 试想每个调用你的函数的人还需要记得去delete掉你在函数中new的堆空间， 否则就会造成内存泄露。

4. 函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型

5. 字符串常量，存放在只读数据段，把该字符串常量存放的只读数据段的首地址赋值给了局部变量的指针后是可以返回出去的(只读数据段不会释放)



