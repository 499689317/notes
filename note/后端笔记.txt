
node.js环境 v4.4.5
npm 2.15.5

///////////////
// 4个demo文件
///////////////
index.js
server.js
router.js
requestHandlers.js

/////////////
// server.js
/////////////

// 创建一个http服务器
var http = require('http');
var url = require('url');

function start(route, handle) {

	http.createServer(function(request,response) {

		var pathname = url.parse(request.url).pathname;// 请求的URL

		console.log('Request for' + pathname + 'received')

		// var content = route(handle, pathname);// 路由(将处理程序回流到路由中)
		
		// 非阻塞操作
		// route(handle, pathname, response);

		// response.writeHead(200,{'Content-Type': 'text/plain'});
		// response.write(content);
		// response.end();
		
		/**
		 * 创建request监听器
		 * data事件收集数据
		 * end事件数据收集完后回调
		 */
		var postData = '';
		request.setEncoding('utf8');// 重新进行编码

		// 如果传输的数据过大，data数据会分成多次传输
		// 也就是说request的data事件将会触发多次
		// 直到data传输完触发end事件
		// 数据传输完后在end事件中由路由来分发处理路线

		request.addListener('data',function(postDataChunk) {

			// 收集所有的数据块
			postData += postDataChunk;
			console.log('Received POST data chunk' + postDataChunk + '.')
		});
		request.addListener('end',function() {

			// 数据收集完成
			route(handle, pathname, response, postData);
		});
	}).listen(8888);

	console.log('Server has started')
}

/**
 * 将server.js变成一个模块
 */
exports.start = start;

/////////////
// router.js
/////////////

/**
 * 针对不同的URL有不同的处理方式
 */
function route(handle, pathname, response, postData) {

	console.log('route a request for' + pathname)

	// 路由请求处理目标
	if (typeof handle[pathname] === 'function') {
		// return handle[pathname]();
		handle[pathname](response, postData);
	} else {
		console.log('No request handle found for' + pathname)
		// return '404 Not Found';
		response.writeHead(404, {'Content-Type': 'text/plain'});
		response.write('404 Not Found');
		response.end();
	}
}

/////////////
// requestHandlers.js
/////////////

// 跟据路由处理不同的业务逻辑

var exec = require('child_process').exec;// 实现非阻塞操作

// 调用start接口时响应逻辑代码
function start(response, postData) {
	console.log('Request handler start was called')

	// 阻塞代码执行(node中没有sleep方法)
	// 此处需要注意一点:
	// 如果执行sleep方法并且不使用非阻塞处理,在并行处理start与upload接口时,只有执行完start方法后才能执行upload
	// 也就是说upload此时必须要等待10秒才能执行
	// function sleep(dt) {
	// 	var startTime = +new Date;
	// 	while(+new Date < startTime + dt);
	// }
	// sleep(10000);

	/*
	 * setTimeout在js中不会阻塞代码的执行
	 */
	// setTimeout(function() {
		// return 'Hello Start';
	// },10000);
	
	// 非阻塞操作ls -lah
	// 第一个参数一般为耗时的指令
	// exec('find /',function(error, stdout, stderr) {
	// 	response.writeHead(200,{'Content-Type': 'text/plain'});
	// 	response.write(stdout);
	// 	response.end();
	// });
	
	// 返回一个文本区
	var body = '<html>'+
		'<head>'+
		'<meta http-equiv="Content-Type" content="text/html'+
		'charset=UTF-8 />'+
		'</head>'+
		'<body>'+
		'<form action="/upload" method="post">'+
		'<textarea name="text" rows="20" cols="60"></textarea>'+
		'<input type="submit" value="Submit text" />'+
		'</form>'+
		'</body>'+
		'</html>';

	response.writeHead(200,{'Content-Type': 'text/html'});
	response.write(body);
	response.end();
}

// 调用upload接口时响应的逻辑
function upload(response, postData) {
	console.log('Request handler upload was called')
	// return 'Hello Upload';
	
	response.writeHead(200,{'Content-Type': 'text/plain'});
	// response.write('Hello Upload');
	response.write('You are sent: ' + postData);// 响应postData
	response.end();
}

exports.start = start;
exports.upload = upload;

exports.route = route;

/////////////
// index.js
/////////////

// 引入模块，管理创建的http服务器
var server = require('./server');
var router = require('./router');// 引入路由模块
var requestHandlers = require('./requestHandlers');// 引入请求处理程序

// 引入一个对象映射请求处理方法
// 一个URL对应一个逻辑处理单元
var handle = {
};
handle['/'] = requestHandlers.start;
handle['/start'] = requestHandlers.start;
handle['/upload'] = requestHandlers.upload;

server.start(router.route, handle);

