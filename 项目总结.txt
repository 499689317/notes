                                                                      /******************************/
                                                                      /*********项目总结
    工作内容：
    在这段时间我主要负责的模块有：
    活动模块：       花费时间：2天，一天写UI，一天与服务器对接，主要是UI与服务器对接耗时比较多，调试没有遇上很大的问题
    签到模块：       花费时间：一个星期，主要耗时比较多的是调试部份，其中由于没有理解文档内容导致签到逻辑与策划的本意偏移
                      很大一部分时间浪费在与服务器对接时没有先沟通好，导致俩边写了相同的逻辑发生矛盾。
    礼包模块：       花费时间：一个多星期，主要耗时多的是需求的变化，其中需求的变化占了修改的绝大部分时间，并且该模块可能会
                      砍掉。
    充值模块：       花费时间：俩个多星期，主要耗时多的是调试与平台对接，其中调试花费了很大一部分时间，主要是因为充值模块关系到
                      游戏的关键，所以调试时测试得比较细心，并且与其它平台对接有些点都比较难以测试。
    一元礼包：       花费时间：一个星期，主要耗时比较多的是测试，与充值差不多的是都按平台分开写成单独的文件，但该模块现已经被砍掉
    分享：           花费时间：1天，主要写UI，同步奖品数据，由于数据是写死的，相对没什么问题，但该模块现已被砍掉
    新手引导：       花费时间：将近写了一个多月，BUG比较多的模块，相对没什么技术难点，但需要插到其它代码中，能发生许多意想不到的问题



   	入职第一个星期：2015年06/15



   	将项目运行在自已的电脑上
   	使用编辑器       Sublime Text
   	安装本地服务器平台         XAMPP Control Panel（类似windows的iis）
   	将工程放入xampp安装文件夹下的www目录中
   	运行流览器运行本地的工程      127.0.0.1/hl-0.3/index.html
   	1>.  http://pixijs.github.io/examples/index.html?s=demos&f=batch.js&title=Particle%20Container
   		这个网页有比较多pixi的test,主要都是关于渲染
   		pixi中没有过多关于动作的Action刲装，这方面弱于cocos
   		使用pixi的api写一些简单的页面，主要了解一个js脚本是如何在网页中运行的，这里于cocos2d-js不一样(cocos2d-js生成工程后直接写js文件代码)
   	2>.  http://pixijs.github.io/docs/PIXI.CanvasRenderer.html
   		github里边有比较多的api可供查阅，实际使用的不多，主要使用前面已经刲好的库
   		刚开始写例子的时候有一些问题，比如：js代码写完后(不管是内嵌代码还是外部的js文件)要用document.body.appendElement方法将pixi的导演对象插入到网页中(这在之前是没有遇到过的)
   		在cocos中的Appdelegate文件中使用了loop方法刷帧，但写pixi时要自己写这个方法
   	3>.  https://github.com/smallnewer/bugs/issues
   		公司的github，在上面写东西时使用Markdown语法，如：
   		````   代码段 ````
   		`单句代码`
      *字体加粗*
   		#   ------一级标题
   		##  ------二级标题------类推
   		* / +      无序分行
   		[]        是否作标记      [x]   已作标记
   		等等   --------------------------------------具体祥细请看：https://github.com/cssmagic/blog/issues/13


   	入职第二星期：2015年06/23



   	写活动、礼包UI
   	主要问题在于对api不是很熟     =========     例如实现按钮的状态改变
   	使用scrollerview时注间参数。。。。。。
   	入职第三个星期：2015年06/30
   	写签到与充值UI
   	略


   	入职一个月


   	写信箱
   	1>.了解前端与后端的通信，前端每次请求对应后端的一次回应
   	2>.前端使用ajax请求：有三个参数
   	      type:'post' -----'get'   -------一般来说请求方式有俩种
   	      post请求中所数据与url分开了，get请求直接将数据接到url后面
   	      由于安全性不一样，一般在作修改时用post请求，查旬时用get请求，get请求的速度远大于post
   	      ulr : 服务器地址 + 接口
   	      data ：请求时所带的数据
   	了解了js是一种单线程脚本，Chrome流览器的js解析引擎是v8引擎，v8是目前性能比较好的js解析引擎
   	由于js是单线程语言，为了不会阻塞进程，js使用异步回调等方式来解决这个问题，明白了js的异步回调机制，我们就很容易对代码进行抽象与拓展了
   	3>.在pixi中获取大图资源时不用在图片名称前加#号，但在cocos中要加
   	4>.获取纹理俩种方式：
   		fromImage   ----- 碎图中取资源
   		fromFrame   ----- 大图中取小图



   	问题1：由于js终究还是脚本，如何加强整个工程（或者单个对象）的拓展性（设计模式？？？？还是增强文件与文件间的管理？？？？？？如何实现？？？？？？？、）
   	问题2：关于流览器为何要与js耦合到一起？？（js本身只是几种标准的组合ECMAScript,BOM,DOM）是否能够根据流览器提供的接口改变流览器，但这样做对于流览器开发商来说有何意义
   	问题3：DOM中的事件（事件冒泡与事件捕获）任何一个DOM节点都有事件属性是否说明我们在js文件中所有的挂事件的对象都对应一个DOM节点？？？？？？？



   	入职第二个月初：2015年07/8
   	


   	竟技场模块完成
   	1>.解决竟技场中UI与逻辑关系，进一步对项目的了解，对项目中的api有更进一步的熟练
   	2>.使用了js中的定时器setInterval，理解定时器中参数，在使用时定时器会根据间隔时间延时(有利有弊)
   	3>.使用完了的定时器一定要清除--------很重要
   	4>.进一步明白了前端展示与后端逻辑的关系，对前后端默契配合有了一个新的认识

   	在竟技场模块中不仅是前端与后端需要配合好，这里我学到了一个程序员需要接受别人的思想，理解别人的成果，每个人想问题的方式不同，解决问题的方法也不相同，
   	学会看别人的代码很重要，取其精华，弃其糟粕。



   	2015年07/15



  	与服务器对接签到--------------配合很重要
  	一般服务器返回对象与数组，根据服务器的返回的状态或数据展示到ui     --------可以将服务器、数据库、前端看成是一个大的MVC框架
  	对接充值、写新手引导

  	1>.与玩吧方面的对接，因为可能要与很多平台对接，所以分平台处理(ENV变量)
  	2>.原理：1.前端展示，必要的的ui展示吸引玩家消费
  			 1.1.  根据不同平台加载不同平台的服务器数据
  			 1.2.  购买操作前端表现实际只是用户点击与ui展示同步，其中所有的购买逻辑对于前端来说是透明的
  			 1.3.  所以只改变点击就可以实现整个界面的复用
  			 2.玩家每次点击购买实际上是请求了后端的购买接口，玩吧中购买请求成功后返回ok==1后确定购买成功，此时同步ui数据
  			 2.1.  如果ok!=1   errcode == 1112 星星不够 点击购买星星 ------购买星星后有三个回调需要处理
  			 2.2.  lb平台直接使用人民币支付，没有这一步（但有类似的回调，后面有讲到）
  			 3.lb平台中，在一进入lb游戏平台后就挂起事件监听
  			 3.1.  用户点击购买发送请求到服务器成功后回调一个window方法
  			 3.2.  这时候服务器触发一进入挂起的事件，并传过来一个参数，根据这个参数来判断是否购买成功
  			 3.2.1. 如果未完成支付，提示用户并退出
  			 3.2.2. 如果支付成功，此时（用订单id）不断的定时发送一个接口请求物品，如果物品请求成功此时将定时器停止，不成功将不断检测
  	3>.新手引导此处不记录。




  	以下是我自己在自学js中总结归纳的一些东西(有点多，只拿出了部份)




  	1.JS中Object类型

  	new Object创建一个Object类实例，相当于所有对象都继承自Object
  	每个Object实例都具有常用属性和方法：
  	constructor:保存着用于创建当前对象的构造函数
  	isPrototypeOf(Object):用于检查传入的对象是否是传入的对象的原型
  	toLocaleString():返回对象的字符串表示
  	toString():返回对象的字符串表示
  	valueOf():返回对象的字符串、数值、布尔值表示，通常与toString()返回值相同
  	等等其它一些属性与方法

  	2.JS中函数

  	JS中函数参数列表类似于一个数组，在函数体内可以通过arguments对象来访问这个参数数组。arguments只是获取参数的一个副本，参数与arguments只是值相同，它们内存空间不相同
  	JS中没有函数重载的用法，原因是JS中对函数参数是动态分配的，如果有俩个函数名相同参数列表不同的函数，解析器只取得后定义的那个函数
  	JS中变量赋值（访问变量）有俩种方式：
  	方式一：基本类型值都是传值
  	方式二：由多个值构成的对象都是传引用
  	JS中所有函数的参数都是按值传递的，生成一个副本
  	函数名实际上也是一个指向函数对象的指针
  	函数声明语法：function test () {} //可以在此函数前使用该函数
  	函数表达式语法：var test = function(){} //不可以在此函数定义前使用该函数
  	如果访问函数的名字而不带后面的小括号，仅仅只是访问该函数的指针并不执行函数体
  	在函数内部有俩个特殊的对象：arguments和this,this表示的是函数的当前执行环境
  	每个函数都包含两个属性：lenght和prototype
  	lenght:表示函数希望接收的命名参数的个数
  	prototype:对于引用类型来说（包括函数），prototype是保存它们所有实例方法的真正所在(prototype是一个指针，指向一个对象，这个对象包含特定类型所有实例共享的属性和方法)，如toString和valueOf()等方法都是保存在prototype名下，只不过是通过不同实例访问而已
  	函数都包含2个非继承而的方法：apply()与call()这2个方法的用途是在特定的作用域中调用函数（扩充作用域），第一个参数指定函数运行的作用域，第二个参数传入参数列表

  	3.创建对象

  	工厂模式：批量生产多组相似对象，没有对象类型概念
  	构造函数：原生构造--Object、Array等;自定义构造--都有一个constructor(构造函数)属性、instanceof操作符标识对象类型，可以将它的实列标识为一种特定的类型，每个对象创建都会生成一个该对象的属性和方法（性能差）
  	原型构造：使用对象的prototype属性共享生成的相同属性与方法，对构造函数进行优化，所有原型对象object.prototype都会自动获取一个constructor属性，这个属性包含一个指向所在函数的指针，通过这个构造函数我们可以继续为原型对象添加属性与方法