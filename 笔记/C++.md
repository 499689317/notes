
## C++

***

1.目前C/C++编译器最流行的就是gcc与g++
2.安装编译器，在windows下使用gcc与g++是通过安装MinGW实现的
3.MinGW(Minimalist GNU on Windows)安装后可以使用很多GNU(Linux下一个著名的项目)工具，包含了gcc/g++/gdb等工具(MinGW\lib下有标准库;MinGW\include下有头文件)
4.把MinGW文件夹放入C盘根目录
5.命令执行时('gcc'不是内部或外部命令)，会在当前目录下查找名为gcc可执行文件，如果查不到就在系统环境变量path记录的路径里寻找gcc可执行文件（1.可以用绝对路径来调用gcc可执行文件;2.把gcc路径写入系统环境变量中）,环境变量设置完后要重起windows
6.gcc虽然可以编译C++代码，但是不能进行C++的连接函数库操作，所以针对C++代码一般使用g++编译
7.在cmd下编译时要在当前C/C++文件目录路径下进行
8.Ctrl + B执行上一次的编译命令;Ctrl+Shift+B选择执行哪个命令(C++ Single File编译/C++ Single File - Run运行)

***

### 2015/10/23

1.目前的Linux源码会把模块相关的文档说明保存在源码目录的documention的文件夹下，如果待分析的模块没有文档说明，这多少会增加定位关键源码文件的难度，但是不会导致我们找不到我们要分析的源码.
2.Linux内核结构
	a.系统调用接口(SCI):open,read,write等系统调用
	b.进程管理(PM):创建进程,删除进程,调度进程等
	c.内存管理(MM):内存分配,管理等
	d.虚拟文件系统(VFS):为多种文件系统提供统一的操作接口
	e.网络协议栈:提供各种网络协议
	f.CPU架构相关代码(Arch):为的是提高移植性
	g.设备驱动程序(DD):各种设备驱动，占到内核的70%左右代码


### 2015/10/24

1.Linux源码目录
	a.Arch:存放处理器相关代码，下设子目录对应具体的cpu，每个子目录有boot（系统引导）,mm（存储管理）,以及kernel（系统调用）三个子目录
	b.Include:内核所需的大部分头文件目录，与平台无关的在include/linux子目录下，与平台相关的则放在include相应的子目录中
	c.fs:存放各种文件系统的实现代码
	d.init:init子目录包含核心的初始化代码（非系统引导代码）,其中包含两个文件main.c和version.c，可以用来研究核心如何工作
	e.ipc:包含核心进程间的通信代码
	f.kernel:包含内核管理的核心代码。与硬件相关代码放在arch/*/kernel目录下
	g.mm:包含了所有的内存管理代码。与硬件相关的内存管理代码位于arch/*/mm目录下
	h.scripts:包含用于配置核心的脚本文件
	i.lib:包含了核心的库代码，与硬件相关的库代码被放在arch/*/lib/目录下


### 2015/10/26

1.引用传参是C++的特性，C语言不支持引用传参
2.但实际在使用时候C语法却可以使用引用传参


### 2015/10/27

1.要使用C++的多态必须要使用虚函数
2.必须要使用指针或引用
3.一个类只有有了虚函数才会有一张虚函数表，多态就是通过这张表实现的
4.对象间的赋值并不能把虚表从一个类对象赋值给另一个对象(对角访问虚函数并没有通过虚函数表)


### 2016/7/26

___

c++中typedef用法
___

1. 复杂声明替换
	('左右法则'解析复杂声明)
	从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
	int (*func)(int *p);
	首先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int*类型的形参，返回值类型是int。
	int (*func[5])(int *);
	func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int*类型的形参，返回值类型为int。

2. 类型替换(处理支持数据类型不同的平台)
	typedef long double REAL;// 长整型
	typedef double REAL;// 不支持长整型平台
	typedef float REAL;// 不支持double型平台

3. struct声明
	c语言中声明struct新对象时需要struct关键字(如: struct 结构名 对象名)
	struct PointStruct {
		int x;
		int y;
	};
	struct PointStruct p;
	使用typedef简化操作：
	typedef struct PointStruct {
		int x;
		int y;
	}POINT;
	// 声明结构体新对象
	POINT p;

4. 与宏不一样，定义了一种类型的新别名，不是简单的字符串替换

### 2016/8/9/

+ 向前说明：
class A;
class B;
与头文件引用：
include "A.h"
include "B.h"
区别：
向前说明一般用于不完全类型引用(incomplete type)

___

不完全类型是指：
	包括那些类型信息没不完整的对象类型以及空类型(void)，前者是指大小(size),内存布局(layout),对齐方式都还未知的模糊类型
___

用法：

* A.h头文件

````
class A
{......};
````

* B.h头文件

````
// A类的向前声明
class A;
class B
{
	private:
		// 以下A都是不完整类型
		A *ap;
		int func(const A &a, const A &a2);
};
````

> B.h头文件并没有包含A的头文件，但可以通过编译，因为B.h头文件只用到了A类的指针与引用，而在C++标准中定义指针与引用时不需要类的完整信息
> 当通过指针或引用调用成员方法时需要类的完整信息
> 
> 不完全类型只能以有限方式使用，不能定义该类型的对象，不完全类型只能用于定义指向该类型的指针及引用，或者用于声明(而不是定义)>使用该类型作为形参类型或返回类型的函数。
> 
> 成员函数不占类对象的大小，所以c++编译器还是可以确定对象的大小。
